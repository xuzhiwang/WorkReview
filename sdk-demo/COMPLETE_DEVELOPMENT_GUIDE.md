# ä»£ç è´¨é‡ä¸è‡ªåŠ¨åŒ–å¼€å‘å®Œæ•´æŒ‡å—

> ç°ä»£è½¯ä»¶å¼€å‘çš„ç»ˆææ–¹æ³•è®º - ä»ä»£ç è´¨é‡åˆ°AIè¾…åŠ©å¼€å‘çš„å…¨æ–¹ä½æŒ‡å—

## ğŸ“‹ ç›®å½•

1. [ä»£ç è´¨é‡åŸºç¡€ç†è®º](#1-ä»£ç è´¨é‡åŸºç¡€ç†è®º)
2. [é™æ€ä»£ç åˆ†æ](#2-é™æ€ä»£ç åˆ†æ)
3. [åŠ¨æ€ä»£ç åˆ†æ](#3-åŠ¨æ€ä»£ç åˆ†æ)
4. [ä»£ç å®¡æŸ¥æ–¹æ³•è®º](#4-ä»£ç å®¡æŸ¥æ–¹æ³•è®º)
5. [è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥](#5-è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥)
6. [æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²](#6-æŒç»­é›†æˆæŒç»­éƒ¨ç½²)
7. [AIè¾…åŠ©å¼€å‘](#7-aiè¾…åŠ©å¼€å‘)
8. [ä»£ç é‡æ„æŠ€æœ¯](#8-ä»£ç é‡æ„æŠ€æœ¯)
9. [æ€§èƒ½ä¼˜åŒ–æ–¹æ³•](#9-æ€§èƒ½ä¼˜åŒ–æ–¹æ³•)
10. [å®‰å…¨ç¼–ç¨‹å®è·µ](#10-å®‰å…¨ç¼–ç¨‹å®è·µ)
11. [æ–‡æ¡£é©±åŠ¨å¼€å‘](#11-æ–‡æ¡£é©±åŠ¨å¼€å‘)
12. [å›¢é˜Ÿåä½œå·¥å…·](#12-å›¢é˜Ÿåä½œå·¥å…·)
13. [ç›‘æ§ä¸å¯è§‚æµ‹æ€§](#13-ç›‘æ§ä¸å¯è§‚æµ‹æ€§)
14. [æŠ€æœ¯å€ºåŠ¡ç®¡ç†](#14-æŠ€æœ¯å€ºåŠ¡ç®¡ç†)
15. [å®æˆ˜æ¡ˆä¾‹åˆ†æ](#15-å®æˆ˜æ¡ˆä¾‹åˆ†æ)

---

## 1. ä»£ç è´¨é‡åŸºç¡€ç†è®º

### 1.1 ä»£ç è´¨é‡çš„å®šä¹‰ä¸ç»´åº¦

#### å†…éƒ¨è´¨é‡ï¼ˆå¼€å‘è€…è§†è§’ï¼‰
- **å¯è¯»æ€§ï¼ˆReadabilityï¼‰**ï¼šä»£ç æ˜¯å¦æ˜“äºç†è§£
- **å¯ç»´æŠ¤æ€§ï¼ˆMaintainabilityï¼‰**ï¼šä¿®æ”¹ä»£ç çš„éš¾æ˜“ç¨‹åº¦
- **å¯æµ‹è¯•æ€§ï¼ˆTestabilityï¼‰**ï¼šç¼–å†™æµ‹è¯•çš„éš¾æ˜“ç¨‹åº¦
- **å¯æ‰©å±•æ€§ï¼ˆExtensibilityï¼‰**ï¼šæ·»åŠ æ–°åŠŸèƒ½çš„éš¾æ˜“ç¨‹åº¦
- **å¤ç”¨æ€§ï¼ˆReusabilityï¼‰**ï¼šä»£ç ç»„ä»¶çš„é‡ç”¨ç¨‹åº¦

#### å¤–éƒ¨è´¨é‡ï¼ˆç”¨æˆ·è§†è§’ï¼‰
- **åŠŸèƒ½æ€§ï¼ˆFunctionalityï¼‰**ï¼šè½¯ä»¶æ˜¯å¦æ»¡è¶³éœ€æ±‚
- **å¯é æ€§ï¼ˆReliabilityï¼‰**ï¼šè½¯ä»¶åœ¨æŒ‡å®šæ¡ä»¶ä¸‹çš„ç¨³å®šæ€§
- **æ€§èƒ½ï¼ˆPerformanceï¼‰**ï¼šå“åº”æ—¶é—´ã€ååé‡ã€èµ„æºä½¿ç”¨
- **å®‰å…¨æ€§ï¼ˆSecurityï¼‰**ï¼šæŠµå¾¡æ¶æ„æ”»å‡»çš„èƒ½åŠ›
- **å…¼å®¹æ€§ï¼ˆCompatibilityï¼‰**ï¼šä¸å…¶ä»–ç³»ç»Ÿçš„äº’æ“ä½œæ€§

### 1.2 ä»£ç è´¨é‡åº¦é‡æŒ‡æ ‡

#### å¤æ‚åº¦æŒ‡æ ‡
```
åœˆå¤æ‚åº¦ï¼ˆCyclomatic Complexityï¼‰
- ä½å¤æ‚åº¦ï¼š1-10ï¼ˆç®€å•ï¼‰
- ä¸­å¤æ‚åº¦ï¼š11-20ï¼ˆä¸­ç­‰ï¼‰
- é«˜å¤æ‚åº¦ï¼š21-50ï¼ˆå¤æ‚ï¼‰
- æé«˜å¤æ‚åº¦ï¼š>50ï¼ˆæå…¶å¤æ‚ï¼Œéœ€è¦é‡æ„ï¼‰

è®¤çŸ¥å¤æ‚åº¦ï¼ˆCognitive Complexityï¼‰
- è¡¡é‡ä»£ç ç†è§£éš¾åº¦
- è€ƒè™‘åµŒå¥—ã€é€’å½’ã€è·³è½¬ç­‰å› ç´ 

Halsteadå¤æ‚åº¦
- åŸºäºæ“ä½œç¬¦å’Œæ“ä½œæ•°çš„å¤æ‚åº¦è®¡ç®—
- åŒ…æ‹¬ç¨‹åºé•¿åº¦ã€è¯æ±‡é‡ã€éš¾åº¦ã€å·¥ä½œé‡
```

#### è€¦åˆåº¦æŒ‡æ ‡
```
ä¼ å…¥è€¦åˆï¼ˆCa - Afferent Couplingï¼‰
- ä¾èµ–å½“å‰æ¨¡å—çš„å…¶ä»–æ¨¡å—æ•°é‡

ä¼ å‡ºè€¦åˆï¼ˆCe - Efferent Couplingï¼‰
- å½“å‰æ¨¡å—ä¾èµ–çš„å…¶ä»–æ¨¡å—æ•°é‡

ä¸ç¨³å®šæ€§ï¼ˆI = Ce / (Ca + Ce)ï¼‰
- 0ï¼šå®Œå…¨ç¨³å®š
- 1ï¼šå®Œå…¨ä¸ç¨³å®š
```

#### å†…èšåº¦æŒ‡æ ‡
```
åŠŸèƒ½å†…èšï¼ˆFunctional Cohesionï¼‰- æœ€é«˜
ä¿¡æ¯å†…èšï¼ˆInformational Cohesionï¼‰
é€šä¿¡å†…èšï¼ˆCommunicational Cohesionï¼‰
è¿‡ç¨‹å†…èšï¼ˆProcedural Cohesionï¼‰
æ—¶é—´å†…èšï¼ˆTemporal Cohesionï¼‰
é€»è¾‘å†…èšï¼ˆLogical Cohesionï¼‰
å¶ç„¶å†…èšï¼ˆCoincidental Cohesionï¼‰- æœ€ä½
```

### 1.3 SOLIDåŸåˆ™è¯¦è§£

#### S - å•ä¸€èŒè´£åŸåˆ™ï¼ˆSingle Responsibility Principleï¼‰
```cpp
// âŒ è¿åSRP
class User {
    void saveToDatabase();
    void sendEmail();
    void validateInput();
    void generateReport();
};

// âœ… éµå¾ªSRP
class User {
    // åªè´Ÿè´£ç”¨æˆ·æ•°æ®
};

class UserRepository {
    void saveToDatabase(const User& user);
};

class EmailService {
    void sendEmail(const User& user);
};

class UserValidator {
    bool validateInput(const User& user);
};

class ReportGenerator {
    void generateUserReport(const User& user);
};
```

#### O - å¼€é—­åŸåˆ™ï¼ˆOpen/Closed Principleï¼‰
```cpp
// âŒ è¿åOCP
class AreaCalculator {
    double calculateArea(const std::vector<Shape*>& shapes) {
        double area = 0;
        for (auto shape : shapes) {
            if (auto rectangle = dynamic_cast<Rectangle*>(shape)) {
                area += rectangle->width * rectangle->height;
            } else if (auto circle = dynamic_cast<Circle*>(shape)) {
                area += M_PI * circle->radius * circle->radius;
            }
            // æ·»åŠ æ–°å½¢çŠ¶éœ€è¦ä¿®æ”¹è¿™é‡Œ
        }
        return area;
    }
};

// âœ… éµå¾ªOCP
class Shape {
public:
    virtual double calculateArea() const = 0;
    virtual ~Shape() = default;
};

class Rectangle : public Shape {
public:
    double calculateArea() const override {
        return width * height;
    }
private:
    double width, height;
};

class Circle : public Shape {
public:
    double calculateArea() const override {
        return M_PI * radius * radius;
    }
private:
    double radius;
};

class AreaCalculator {
public:
    double calculateArea(const std::vector<std::unique_ptr<Shape>>& shapes) {
        double area = 0;
        for (const auto& shape : shapes) {
            area += shape->calculateArea();
        }
        return area;
    }
};
```

#### L - é‡Œæ°æ›¿æ¢åŸåˆ™ï¼ˆLiskov Substitution Principleï¼‰
```cpp
// âŒ è¿åLSP
class Bird {
public:
    virtual void fly() = 0;
};

class Penguin : public Bird {
public:
    void fly() override {
        throw std::runtime_error("Penguins can't fly!");
    }
};

// âœ… éµå¾ªLSP
class Bird {
public:
    virtual void move() = 0;
    virtual ~Bird() = default;
};

class FlyingBird : public Bird {
public:
    virtual void fly() = 0;
    void move() override { fly(); }
};

class SwimmingBird : public Bird {
public:
    virtual void swim() = 0;
    void move() override { swim(); }
};

class Eagle : public FlyingBird {
public:
    void fly() override {
        // è€é¹°é£è¡Œå®ç°
    }
};

class Penguin : public SwimmingBird {
public:
    void swim() override {
        // ä¼é¹…æ¸¸æ³³å®ç°
    }
};
```

#### I - æ¥å£éš”ç¦»åŸåˆ™ï¼ˆInterface Segregation Principleï¼‰
```cpp
// âŒ è¿åISP
class Worker {
public:
    virtual void work() = 0;
    virtual void eat() = 0;
    virtual void sleep() = 0;
};

class Robot : public Worker {
public:
    void work() override { /* å·¥ä½œ */ }
    void eat() override { /* æœºå™¨äººä¸éœ€è¦åƒé¥­ */ }
    void sleep() override { /* æœºå™¨äººä¸éœ€è¦ç¡è§‰ */ }
};

// âœ… éµå¾ªISP
class Workable {
public:
    virtual void work() = 0;
    virtual ~Workable() = default;
};

class Eatable {
public:
    virtual void eat() = 0;
    virtual ~Eatable() = default;
};

class Sleepable {
public:
    virtual void sleep() = 0;
    virtual ~Sleepable() = default;
};

class Human : public Workable, public Eatable, public Sleepable {
public:
    void work() override { /* äººç±»å·¥ä½œ */ }
    void eat() override { /* äººç±»åƒé¥­ */ }
    void sleep() override { /* äººç±»ç¡è§‰ */ }
};

class Robot : public Workable {
public:
    void work() override { /* æœºå™¨äººå·¥ä½œ */ }
};
```

#### D - ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDependency Inversion Principleï¼‰
```cpp
// âŒ è¿åDIP
class MySQLDatabase {
public:
    void save(const std::string& data) {
        // MySQLç‰¹å®šçš„ä¿å­˜é€»è¾‘
    }
};

class UserService {
private:
    MySQLDatabase database; // ç›´æ¥ä¾èµ–å…·ä½“å®ç°
public:
    void saveUser(const User& user) {
        database.save(user.toString());
    }
};

// âœ… éµå¾ªDIP
class Database {
public:
    virtual void save(const std::string& data) = 0;
    virtual ~Database() = default;
};

class MySQLDatabase : public Database {
public:
    void save(const std::string& data) override {
        // MySQLç‰¹å®šçš„ä¿å­˜é€»è¾‘
    }
};

class PostgreSQLDatabase : public Database {
public:
    void save(const std::string& data) override {
        // PostgreSQLç‰¹å®šçš„ä¿å­˜é€»è¾‘
    }
};

class UserService {
private:
    std::unique_ptr<Database> database; // ä¾èµ–æŠ½è±¡
public:
    UserService(std::unique_ptr<Database> db) : database(std::move(db)) {}

    void saveUser(const User& user) {
        database->save(user.toString());
    }
};
```

---

## 2. é™æ€ä»£ç åˆ†æ

### 2.1 é™æ€åˆ†æå·¥å…·å¯¹æ¯”

#### C/C++é™æ€åˆ†æå·¥å…·

| å·¥å…· | ç±»å‹ | ä¼˜åŠ¿ | åŠ£åŠ¿ | é€‚ç”¨åœºæ™¯ |
|------|------|------|------|----------|
| **Clang Static Analyzer** | å…è´¹/å¼€æº | é›†æˆåº¦é«˜ã€è¯¯æŠ¥ç‡ä½ | æ£€æŸ¥è§„åˆ™æœ‰é™ | æ—¥å¸¸å¼€å‘ |
| **Cppcheck** | å…è´¹/å¼€æº | è½»é‡çº§ã€æ˜“é›†æˆ | æ£€æŸ¥æ·±åº¦æœ‰é™ | CI/CDé›†æˆ |
| **PVS-Studio** | å•†ä¸š | æ£€æŸ¥å…¨é¢ã€è¯¯æŠ¥ç‡ä½ | ä»·æ ¼æ˜‚è´µ | ä¼ä¸šçº§é¡¹ç›® |
| **PC-lint Plus** | å•†ä¸š | å†å²æ‚ ä¹…ã€è§„åˆ™ä¸°å¯Œ | é…ç½®å¤æ‚ | å®‰å…¨å…³é”®ç³»ç»Ÿ |
| **SonarQube** | å…è´¹/å•†ä¸š | å¤šè¯­è¨€æ”¯æŒã€Webç•Œé¢ | èµ„æºæ¶ˆè€—å¤§ | å›¢é˜Ÿåä½œ |
| **CodeQL** | å…è´¹/å•†ä¸š | è¯­ä¹‰åˆ†æå¼ºå¤§ | å­¦ä¹ æˆæœ¬é«˜ | å®‰å…¨å®¡è®¡ |

#### é…ç½®ç¤ºä¾‹

**Clang-Tidyé…ç½®ï¼ˆ.clang-tidyï¼‰**
```yaml
---
Checks: >
  -*,
  bugprone-*,
  cert-*,
  clang-analyzer-*,
  cppcoreguidelines-*,
  google-*,
  hicpp-*,
  llvm-*,
  misc-*,
  modernize-*,
  performance-*,
  portability-*,
  readability-*,
  -bugprone-easily-swappable-parameters,
  -cppcoreguidelines-avoid-magic-numbers,
  -cppcoreguidelines-pro-bounds-pointer-arithmetic,
  -cppcoreguidelines-pro-type-reinterpret-cast,
  -google-readability-todo,
  -hicpp-signed-bitwise,
  -readability-magic-numbers

WarningsAsErrors: ''
HeaderFilterRegex: '.*'
AnalyzeTemporaryDtors: false
FormatStyle: file
CheckOptions:
  - key: readability-identifier-naming.NamespaceCase
    value: lower_case
  - key: readability-identifier-naming.ClassCase
    value: CamelCase
  - key: readability-identifier-naming.FunctionCase
    value: camelCase
  - key: readability-identifier-naming.VariableCase
    value: camelCase
  - key: readability-identifier-naming.ConstantCase
    value: UPPER_CASE
  - key: readability-identifier-naming.EnumCase
    value: CamelCase
  - key: readability-identifier-naming.EnumConstantCase
    value: UPPER_CASE
  - key: readability-function-cognitive-complexity.Threshold
    value: 25
  - key: readability-function-size.LineThreshold
    value: 80
  - key: readability-function-size.StatementThreshold
    value: 800
```

**Cppchecké…ç½®ï¼ˆcppcheck.cfgï¼‰**
```xml
<?xml version="1.0"?>
<def format="2">
  <define name="NDEBUG" value=""/>
  <define name="DEBUG" value="1"/>

  <function name="custom_malloc,malloc">
    <alloc init="false" buffer-size="malloc">1</alloc>
    <returnValue type="void *"/>
    <arg nr="1">
      <not-uninit/>
    </arg>
  </function>

  <function name="custom_free,free">
    <dealloc>1</dealloc>
    <arg nr="1">
      <not-uninit/>
    </arg>
  </function>

  <markup ext=".qml" aftercode="true" reporterrors="false"/>

  <suppress>
    <id>missingIncludeSystem</id>
  </suppress>

  <suppress>
    <id>unmatchedSuppression</id>
  </suppress>
</def>
```

### 2.2 è‡ªå®šä¹‰é™æ€åˆ†æè§„åˆ™

#### ä½¿ç”¨Clang LibToolingåˆ›å»ºè‡ªå®šä¹‰æ£€æŸ¥å™¨
```cpp
// CustomChecker.cpp
#include "clang/StaticAnalyzer/Core/Checker.h"
#include "clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"
#include "clang/StaticAnalyzer/Frontend/CheckerRegistry.h"

using namespace clang;
using namespace ento;

namespace {
class CustomChecker : public Checker<check::PreCall> {
public:
    void checkPreCall(const CallEvent &Call, CheckerContext &C) const;
};
} // end anonymous namespace

void CustomChecker::checkPreCall(const CallEvent &Call, CheckerContext &C) const {
    const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(Call.getDecl());
    if (!FD)
        return;

    // æ£€æŸ¥æ˜¯å¦è°ƒç”¨äº†å±é™©å‡½æ•°
    if (FD->getName() == "strcpy") {
        ExplodedNode *N = C.generateErrorNode();
        if (!N)
            return;

        auto R = std::make_unique<PathSensitiveBugReport>(
            BugType, "Use of dangerous function 'strcpy'", N);
        R->addRange(Call.getSourceRange());
        C.emitReport(std::move(R));
    }
}

// æ³¨å†Œæ£€æŸ¥å™¨
extern "C" void clang_registerCheckers(CheckerRegistry &registry) {
    registry.addChecker<CustomChecker>(
        "custom.DangerousFunction",
        "Checks for dangerous function calls",
        "");
}
```

### 2.3 ä»£ç åº¦é‡è‡ªåŠ¨åŒ–

#### å¤æ‚åº¦åˆ†æè„šæœ¬
```python
#!/usr/bin/env python3
"""
ä»£ç å¤æ‚åº¦åˆ†æå·¥å…·
"""

import os
import re
import json
from typing import Dict, List, Tuple
from dataclasses import dataclass
from pathlib import Path

@dataclass
class FunctionMetrics:
    name: str
    file: str
    line: int
    cyclomatic_complexity: int
    cognitive_complexity: int
    lines_of_code: int
    parameters: int

class ComplexityAnalyzer:
    def __init__(self):
        self.complexity_keywords = [
            'if', 'else', 'elif', 'while', 'for', 'switch', 'case',
            'catch', 'try', 'except', 'finally', '&&', '||', '?'
        ]

    def analyze_file(self, file_path: str) -> List[FunctionMetrics]:
        """åˆ†æå•ä¸ªæ–‡ä»¶çš„å¤æ‚åº¦"""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        functions = self._extract_functions(content)
        metrics = []

        for func in functions:
            cyclomatic = self._calculate_cyclomatic_complexity(func['body'])
            cognitive = self._calculate_cognitive_complexity(func['body'])
            loc = len([line for line in func['body'].split('\n') if line.strip()])
            params = len(func['parameters'])

            metrics.append(FunctionMetrics(
                name=func['name'],
                file=file_path,
                line=func['line'],
                cyclomatic_complexity=cyclomatic,
                cognitive_complexity=cognitive,
                lines_of_code=loc,
                parameters=params
            ))

        return metrics

    def _extract_functions(self, content: str) -> List[Dict]:
        """æå–å‡½æ•°ä¿¡æ¯"""
        # ç®€åŒ–çš„å‡½æ•°æå–ï¼ˆå®é™…åº”è¯¥ä½¿ç”¨ASTï¼‰
        function_pattern = r'(\w+)\s+(\w+)\s*\([^)]*\)\s*\{'
        functions = []

        for match in re.finditer(function_pattern, content):
            func_start = match.start()
            func_name = match.group(2)

            # æ‰¾åˆ°å‡½æ•°ä½“
            brace_count = 0
            func_end = func_start
            for i, char in enumerate(content[func_start:]):
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        func_end = func_start + i + 1
                        break

            func_body = content[func_start:func_end]
            line_number = content[:func_start].count('\n') + 1

            functions.append({
                'name': func_name,
                'body': func_body,
                'line': line_number,
                'parameters': []  # ç®€åŒ–å¤„ç†
            })

        return functions

    def _calculate_cyclomatic_complexity(self, code: str) -> int:
        """è®¡ç®—åœˆå¤æ‚åº¦"""
        complexity = 1  # åŸºç¡€å¤æ‚åº¦

        for keyword in self.complexity_keywords:
            if keyword in ['&&', '||']:
                complexity += code.count(keyword)
            else:
                # ä½¿ç”¨æ­£åˆ™ç¡®ä¿æ˜¯å…³é”®å­—è€Œä¸æ˜¯å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†
                pattern = r'\b' + re.escape(keyword) + r'\b'
                complexity += len(re.findall(pattern, code))

        return complexity

    def _calculate_cognitive_complexity(self, code: str) -> int:
        """è®¡ç®—è®¤çŸ¥å¤æ‚åº¦ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        cognitive = 0
        nesting_level = 0

        lines = code.split('\n')
        for line in lines:
            line = line.strip()

            # è®¡ç®—åµŒå¥—çº§åˆ«
            if any(keyword in line for keyword in ['if', 'while', 'for', 'switch']):
                cognitive += 1 + nesting_level
                if '{' in line:
                    nesting_level += 1
            elif line.startswith('}'):
                nesting_level = max(0, nesting_level - 1)
            elif any(keyword in line for keyword in ['else', 'elif', 'case']):
                cognitive += 1
            elif any(keyword in line for keyword in ['&&', '||']):
                cognitive += 1

        return cognitive

def generate_complexity_report(source_dirs: List[str], output_file: str):
    """ç”Ÿæˆå¤æ‚åº¦æŠ¥å‘Š"""
    analyzer = ComplexityAnalyzer()
    all_metrics = []

    for source_dir in source_dirs:
        for root, dirs, files in os.walk(source_dir):
            for file in files:
                if file.endswith(('.cpp', '.c', '.h', '.hpp')):
                    file_path = os.path.join(root, file)
                    try:
                        metrics = analyzer.analyze_file(file_path)
                        all_metrics.extend(metrics)
                    except Exception as e:
                        print(f"Error analyzing {file_path}: {e}")

    # ç”ŸæˆæŠ¥å‘Š
    report = {
        'summary': {
            'total_functions': len(all_metrics),
            'high_complexity_functions': len([m for m in all_metrics if m.cyclomatic_complexity > 10]),
            'average_complexity': sum(m.cyclomatic_complexity for m in all_metrics) / len(all_metrics) if all_metrics else 0
        },
        'functions': [
            {
                'name': m.name,
                'file': m.file,
                'line': m.line,
                'cyclomatic_complexity': m.cyclomatic_complexity,
                'cognitive_complexity': m.cognitive_complexity,
                'lines_of_code': m.lines_of_code,
                'parameters': m.parameters
            }
            for m in sorted(all_metrics, key=lambda x: x.cyclomatic_complexity, reverse=True)
        ]
    }

    with open(output_file, 'w') as f:
        json.dump(report, f, indent=2)

    print(f"Complexity report generated: {output_file}")
    print(f"Total functions analyzed: {report['summary']['total_functions']}")
    print(f"High complexity functions: {report['summary']['high_complexity_functions']}")
    print(f"Average complexity: {report['summary']['average_complexity']:.2f}")

if __name__ == "__main__":
    generate_complexity_report(['src/', 'include/'], 'complexity_report.json')

---

## 3. åŠ¨æ€ä»£ç åˆ†æ

### 3.1 å†…å­˜åˆ†æå·¥å…·

#### Valgrindè¯¦ç»†ä½¿ç”¨
```bash
# å†…å­˜æ³„æ¼æ£€æµ‹
valgrind --tool=memcheck \
         --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --verbose \
         --log-file=valgrind-out.txt \
         ./your_program

# ç¼“å­˜æ€§èƒ½åˆ†æ
valgrind --tool=cachegrind ./your_program
cg_annotate cachegrind.out.pid

# è°ƒç”¨å›¾åˆ†æ
valgrind --tool=callgrind ./your_program
kcachegrind callgrind.out.pid
```

#### AddressSanitizer (ASan) é…ç½®
```cmake
# CMakeLists.txt
if(ENABLE_ASAN)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=address")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-omit-frame-pointer")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize-address-use-after-scope")
    set(CMAKE_LINKER_FLAGS "${CMAKE_LINKER_FLAGS} -fsanitize=address")
endif()

if(ENABLE_TSAN)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=thread")
    set(CMAKE_LINKER_FLAGS "${CMAKE_LINKER_FLAGS} -fsanitize=thread")
endif()

if(ENABLE_UBSAN)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=undefined")
    set(CMAKE_LINKER_FLAGS "${CMAKE_LINKER_FLAGS} -fsanitize=undefined")
endif()
```

#### å†…å­˜åˆ†æç¤ºä¾‹ä»£ç 
```cpp
// memory_analyzer.cpp
#include <memory>
#include <vector>
#include <chrono>
#include <iostream>

class MemoryProfiler {
private:
    static size_t allocated_bytes;
    static size_t allocation_count;

public:
    static void* operator_new(size_t size) {
        allocated_bytes += size;
        allocation_count++;
        return malloc(size);
    }

    static void operator_delete(void* ptr, size_t size) {
        allocated_bytes -= size;
        allocation_count--;
        free(ptr);
    }

    static void print_stats() {
        std::cout << "Allocated bytes: " << allocated_bytes << std::endl;
        std::cout << "Allocation count: " << allocation_count << std::endl;
    }
};

size_t MemoryProfiler::allocated_bytes = 0;
size_t MemoryProfiler::allocation_count = 0;

// å†…å­˜æ³„æ¼æ£€æµ‹ç¤ºä¾‹
class LeakDetector {
private:
    struct AllocationInfo {
        size_t size;
        const char* file;
        int line;
        std::chrono::time_point<std::chrono::steady_clock> timestamp;
    };

    static std::unordered_map<void*, AllocationInfo> allocations;

public:
    static void* allocate(size_t size, const char* file, int line) {
        void* ptr = malloc(size);
        allocations[ptr] = {size, file, line, std::chrono::steady_clock::now()};
        return ptr;
    }

    static void deallocate(void* ptr) {
        auto it = allocations.find(ptr);
        if (it != allocations.end()) {
            allocations.erase(it);
        }
        free(ptr);
    }

    static void report_leaks() {
        if (!allocations.empty()) {
            std::cout << "Memory leaks detected:" << std::endl;
            for (const auto& [ptr, info] : allocations) {
                auto duration = std::chrono::steady_clock::now() - info.timestamp;
                auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration).count();

                std::cout << "Leak: " << info.size << " bytes at "
                         << info.file << ":" << info.line
                         << " (allocated " << seconds << "s ago)" << std::endl;
            }
        }
    }
};

#define TRACKED_NEW(size) LeakDetector::allocate(size, __FILE__, __LINE__)
#define TRACKED_DELETE(ptr) LeakDetector::deallocate(ptr)
```

### 3.2 æ€§èƒ½åˆ†æå·¥å…·

#### Perfå·¥å…·ä½¿ç”¨
```bash
# CPUæ€§èƒ½åˆ†æ
perf record -g ./your_program
perf report

# çƒ­ç‚¹å‡½æ•°åˆ†æ
perf top -p $(pgrep your_program)

# ç¼“å­˜æœªå‘½ä¸­åˆ†æ
perf stat -e cache-misses,cache-references ./your_program

# åˆ†æ”¯é¢„æµ‹åˆ†æ
perf stat -e branch-misses,branches ./your_program

# ç”Ÿæˆç«ç„°å›¾
perf record -F 99 -g ./your_program
perf script | stackcollapse-perf.pl | flamegraph.pl > flamegraph.svg
```

#### è‡ªå®šä¹‰æ€§èƒ½åˆ†æå™¨
```cpp
// performance_profiler.cpp
#include <chrono>
#include <unordered_map>
#include <string>
#include <iostream>
#include <fstream>

class PerformanceProfiler {
private:
    struct ProfileData {
        std::chrono::high_resolution_clock::time_point start_time;
        std::chrono::nanoseconds total_time{0};
        size_t call_count = 0;
    };

    static std::unordered_map<std::string, ProfileData> profiles;
    static thread_local std::vector<std::string> call_stack;

public:
    class ScopedTimer {
    private:
        std::string name;
        std::chrono::high_resolution_clock::time_point start;

    public:
        ScopedTimer(const std::string& function_name) : name(function_name) {
            start = std::chrono::high_resolution_clock::now();
            call_stack.push_back(name);
            profiles[name].call_count++;
        }

        ~ScopedTimer() {
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
            profiles[name].total_time += duration;
            call_stack.pop_back();
        }
    };

    static void generate_report(const std::string& filename) {
        std::ofstream file(filename);
        file << "Function,Calls,Total Time (ms),Average Time (Î¼s)" << std::endl;

        for (const auto& [name, data] : profiles) {
            double total_ms = data.total_time.count() / 1e6;
            double avg_us = data.total_time.count() / (1e3 * data.call_count);

            file << name << "," << data.call_count << ","
                 << total_ms << "," << avg_us << std::endl;
        }
    }

    static void print_call_stack() {
        std::cout << "Call stack:" << std::endl;
        for (const auto& func : call_stack) {
            std::cout << "  " << func << std::endl;
        }
    }
};

#define PROFILE_FUNCTION() PerformanceProfiler::ScopedTimer timer(__FUNCTION__)
#define PROFILE_SCOPE(name) PerformanceProfiler::ScopedTimer timer(name)

// ä½¿ç”¨ç¤ºä¾‹
void expensive_function() {
    PROFILE_FUNCTION();
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}

void another_function() {
    PROFILE_FUNCTION();
    expensive_function();
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
}
```

### 3.3 å¹¶å‘åˆ†æ

#### ThreadSanitizerä½¿ç”¨
```cpp
// thread_safety_test.cpp
#include <thread>
#include <vector>
#include <atomic>
#include <mutex>

// âŒ æ•°æ®ç«äº‰ç¤ºä¾‹
class UnsafeCounter {
private:
    int count = 0;

public:
    void increment() {
        count++; // æ•°æ®ç«äº‰
    }

    int get() const {
        return count; // æ•°æ®ç«äº‰
    }
};

// âœ… çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬
class SafeCounter {
private:
    mutable std::mutex mtx;
    int count = 0;

public:
    void increment() {
        std::lock_guard<std::mutex> lock(mtx);
        count++;
    }

    int get() const {
        std::lock_guard<std::mutex> lock(mtx);
        return count;
    }
};

// âœ… æ— é”ç‰ˆæœ¬
class LockFreeCounter {
private:
    std::atomic<int> count{0};

public:
    void increment() {
        count.fetch_add(1, std::memory_order_relaxed);
    }

    int get() const {
        return count.load(std::memory_order_relaxed);
    }
};

// æ­»é”æ£€æµ‹ç¤ºä¾‹
class DeadlockExample {
private:
    std::mutex mutex1;
    std::mutex mutex2;

public:
    void function1() {
        std::lock_guard<std::mutex> lock1(mutex1);
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        std::lock_guard<std::mutex> lock2(mutex2); // å¯èƒ½æ­»é”
    }

    void function2() {
        std::lock_guard<std::mutex> lock2(mutex2);
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        std::lock_guard<std::mutex> lock1(mutex1); // å¯èƒ½æ­»é”
    }

    // âœ… é¿å…æ­»é”çš„ç‰ˆæœ¬
    void safe_function1() {
        std::lock(mutex1, mutex2); // åŒæ—¶é”å®š
        std::lock_guard<std::mutex> lock1(mutex1, std::adopt_lock);
        std::lock_guard<std::mutex> lock2(mutex2, std::adopt_lock);
    }

    void safe_function2() {
        std::lock(mutex1, mutex2); // åŒæ—¶é”å®š
        std::lock_guard<std::mutex> lock1(mutex1, std::adopt_lock);
        std::lock_guard<std::mutex> lock2(mutex2, std::adopt_lock);
    }
};
```

---

## 4. ä»£ç å®¡æŸ¥æ–¹æ³•è®º

### 4.1 ä»£ç å®¡æŸ¥æ¸…å•

#### åŠŸèƒ½æ€§æ£€æŸ¥
- [ ] ä»£ç æ˜¯å¦å®ç°äº†é¢„æœŸåŠŸèƒ½ï¼Ÿ
- [ ] è¾¹ç•Œæ¡ä»¶æ˜¯å¦æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] é”™è¯¯å¤„ç†æ˜¯å¦å®Œæ•´ï¼Ÿ
- [ ] è¾“å…¥éªŒè¯æ˜¯å¦å……åˆ†ï¼Ÿ
- [ ] è¾“å‡ºæ ¼å¼æ˜¯å¦æ­£ç¡®ï¼Ÿ

#### å¯è¯»æ€§æ£€æŸ¥
- [ ] å˜é‡å’Œå‡½æ•°å‘½åæ˜¯å¦æ¸…æ™°ï¼Ÿ
- [ ] ä»£ç ç»“æ„æ˜¯å¦é€»è¾‘æ¸…æ™°ï¼Ÿ
- [ ] æ³¨é‡Šæ˜¯å¦å……åˆ†ä¸”å‡†ç¡®ï¼Ÿ
- [ ] ä»£ç é£æ ¼æ˜¯å¦ä¸€è‡´ï¼Ÿ
- [ ] å¤æ‚é€»è¾‘æ˜¯å¦æœ‰è§£é‡Šï¼Ÿ

#### æ€§èƒ½æ£€æŸ¥
- [ ] æ˜¯å¦å­˜åœ¨ä¸å¿…è¦çš„è®¡ç®—ï¼Ÿ
- [ ] å†…å­˜ä½¿ç”¨æ˜¯å¦é«˜æ•ˆï¼Ÿ
- [ ] ç®—æ³•å¤æ‚åº¦æ˜¯å¦åˆç†ï¼Ÿ
- [ ] æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼ï¼Ÿ
- [ ] å¹¶å‘æ€§èƒ½æ˜¯å¦ä¼˜åŒ–ï¼Ÿ

#### å®‰å…¨æ€§æ£€æŸ¥
- [ ] è¾“å…¥æ˜¯å¦ç»è¿‡éªŒè¯ï¼Ÿ
- [ ] æ˜¯å¦å­˜åœ¨ç¼“å†²åŒºæº¢å‡ºé£é™©ï¼Ÿ
- [ ] æ•æ„Ÿæ•°æ®æ˜¯å¦æ­£ç¡®å¤„ç†ï¼Ÿ
- [ ] æƒé™æ£€æŸ¥æ˜¯å¦å……åˆ†ï¼Ÿ
- [ ] æ˜¯å¦ä½¿ç”¨äº†å®‰å…¨çš„APIï¼Ÿ

#### å¯ç»´æŠ¤æ€§æ£€æŸ¥
- [ ] ä»£ç æ˜¯å¦éµå¾ªSOLIDåŸåˆ™ï¼Ÿ
- [ ] è€¦åˆåº¦æ˜¯å¦åˆç†ï¼Ÿ
- [ ] æ˜¯å¦å®¹æ˜“æµ‹è¯•ï¼Ÿ
- [ ] æ˜¯å¦å®¹æ˜“æ‰©å±•ï¼Ÿ
- [ ] æŠ€æœ¯å€ºåŠ¡æ˜¯å¦å¯æ§ï¼Ÿ

### 4.2 è‡ªåŠ¨åŒ–ä»£ç å®¡æŸ¥

#### GitHub Actionsä»£ç å®¡æŸ¥å·¥ä½œæµ
```yaml
# .github/workflows/code-review.yml
name: Automated Code Review

on:
  pull_request:
    branches: [ main, develop ]

jobs:
  static-analysis:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Setup C++
      uses: egor-tensin/setup-gcc@v1
      with:
        version: 11
        platform: x64

    - name: Install tools
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy cppcheck valgrind

    - name: Run Clang-Tidy
      run: |
        clang-tidy src/**/*.cpp -- -std=c++17

    - name: Run Cppcheck
      run: |
        cppcheck --enable=all --xml --xml-version=2 src/ 2> cppcheck-report.xml

    - name: Upload results
      uses: actions/upload-artifact@v3
      with:
        name: static-analysis-results
        path: |
          cppcheck-report.xml

  complexity-analysis:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        pip install lizard radon

    - name: Run complexity analysis
      run: |
        lizard src/ --xml > lizard-report.xml
        radon cc src/ --json > radon-report.json

    - name: Comment PR
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const lizardReport = fs.readFileSync('lizard-report.xml', 'utf8');
          // è§£ææŠ¥å‘Šå¹¶ç”Ÿæˆè¯„è®º

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Run CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: cpp

    - name: Build
      run: |
        mkdir build && cd build
        cmake .. -DCMAKE_BUILD_TYPE=Debug
        make

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
```

#### è‡ªå®šä¹‰ä»£ç å®¡æŸ¥æœºå™¨äºº
```python
#!/usr/bin/env python3
"""
è‡ªåŠ¨åŒ–ä»£ç å®¡æŸ¥æœºå™¨äºº
"""

import os
import re
import json
import subprocess
from typing import List, Dict, Any
from dataclasses import dataclass

@dataclass
class ReviewComment:
    file: str
    line: int
    severity: str
    message: str
    rule: str

class CodeReviewBot:
    def __init__(self):
        self.rules = self._load_rules()

    def _load_rules(self) -> Dict[str, Any]:
        """åŠ è½½å®¡æŸ¥è§„åˆ™"""
        return {
            'naming_conventions': {
                'class_pattern': r'^[A-Z][a-zA-Z0-9]*$',
                'function_pattern': r'^[a-z][a-zA-Z0-9]*$',
                'variable_pattern': r'^[a-z][a-zA-Z0-9_]*$',
                'constant_pattern': r'^[A-Z][A-Z0-9_]*$'
            },
            'complexity_limits': {
                'max_function_length': 50,
                'max_cyclomatic_complexity': 10,
                'max_parameters': 5
            },
            'security_patterns': [
                r'strcpy\s*\(',
                r'strcat\s*\(',
                r'sprintf\s*\(',
                r'gets\s*\('
            ],
            'performance_patterns': [
                r'std::endl',  # å»ºè®®ä½¿ç”¨ '\n'
                r'\.size\(\)\s*==\s*0',  # å»ºè®®ä½¿ç”¨ .empty()
            ]
        }

    def review_file(self, file_path: str) -> List[ReviewComment]:
        """å®¡æŸ¥å•ä¸ªæ–‡ä»¶"""
        comments = []

        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            lines = content.split('\n')

        # å‘½åçº¦å®šæ£€æŸ¥
        comments.extend(self._check_naming_conventions(file_path, content))

        # å¤æ‚åº¦æ£€æŸ¥
        comments.extend(self._check_complexity(file_path, content))

        # å®‰å…¨æ€§æ£€æŸ¥
        comments.extend(self._check_security(file_path, lines))

        # æ€§èƒ½æ£€æŸ¥
        comments.extend(self._check_performance(file_path, lines))

        return comments

    def _check_naming_conventions(self, file_path: str, content: str) -> List[ReviewComment]:
        """æ£€æŸ¥å‘½åçº¦å®š"""
        comments = []

        # æ£€æŸ¥ç±»å
        class_pattern = re.compile(r'class\s+(\w+)')
        for match in class_pattern.finditer(content):
            class_name = match.group(1)
            if not re.match(self.rules['naming_conventions']['class_pattern'], class_name):
                line_num = content[:match.start()].count('\n') + 1
                comments.append(ReviewComment(
                    file=file_path,
                    line=line_num,
                    severity='warning',
                    message=f"Class name '{class_name}' should use PascalCase",
                    rule='naming.class'
                ))

        # æ£€æŸ¥å‡½æ•°å
        function_pattern = re.compile(r'(\w+)\s+(\w+)\s*\([^)]*\)\s*\{')
        for match in function_pattern.finditer(content):
            func_name = match.group(2)
            if not re.match(self.rules['naming_conventions']['function_pattern'], func_name):
                line_num = content[:match.start()].count('\n') + 1
                comments.append(ReviewComment(
                    file=file_path,
                    line=line_num,
                    severity='warning',
                    message=f"Function name '{func_name}' should use camelCase",
                    rule='naming.function'
                ))

        return comments

    def _check_complexity(self, file_path: str, content: str) -> List[ReviewComment]:
        """æ£€æŸ¥å¤æ‚åº¦"""
        comments = []

        # æ£€æŸ¥å‡½æ•°é•¿åº¦
        function_pattern = re.compile(r'(\w+)\s+(\w+)\s*\([^)]*\)\s*\{')
        for match in function_pattern.finditer(content):
            func_start = match.start()
            func_name = match.group(2)

            # æ‰¾åˆ°å‡½æ•°ç»“æŸ
            brace_count = 0
            func_end = func_start
            for i, char in enumerate(content[func_start:]):
                if char == '{':
                    brace_count += 1
                elif char == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        func_end = func_start + i + 1
                        break

            func_body = content[func_start:func_end]
            func_lines = len([line for line in func_body.split('\n') if line.strip()])

            if func_lines > self.rules['complexity_limits']['max_function_length']:
                line_num = content[:func_start].count('\n') + 1
                comments.append(ReviewComment(
                    file=file_path,
                    line=line_num,
                    severity='warning',
                    message=f"Function '{func_name}' is too long ({func_lines} lines). Consider breaking it down.",
                    rule='complexity.function_length'
                ))

        return comments

    def _check_security(self, file_path: str, lines: List[str]) -> List[ReviewComment]:
        """æ£€æŸ¥å®‰å…¨æ€§é—®é¢˜"""
        comments = []

        for i, line in enumerate(lines):
            for pattern in self.rules['security_patterns']:
                if re.search(pattern, line):
                    comments.append(ReviewComment(
                        file=file_path,
                        line=i + 1,
                        severity='error',
                        message=f"Dangerous function detected: {pattern}. Use safer alternatives.",
                        rule='security.dangerous_function'
                    ))

        return comments

    def _check_performance(self, file_path: str, lines: List[str]) -> List[ReviewComment]:
        """æ£€æŸ¥æ€§èƒ½é—®é¢˜"""
        comments = []

        for i, line in enumerate(lines):
            if 'std::endl' in line:
                comments.append(ReviewComment(
                    file=file_path,
                    line=i + 1,
                    severity='info',
                    message="Consider using '\\n' instead of std::endl for better performance",
                    rule='performance.endl'
                ))

            if re.search(r'\.size\(\)\s*==\s*0', line):
                comments.append(ReviewComment(
                    file=file_path,
                    line=i + 1,
                    severity='info',
                    message="Consider using .empty() instead of .size() == 0",
                    rule='performance.empty_check'
                ))

        return comments

    def generate_report(self, comments: List[ReviewComment], output_file: str):
        """ç”Ÿæˆå®¡æŸ¥æŠ¥å‘Š"""
        report = {
            'summary': {
                'total_issues': len(comments),
                'errors': len([c for c in comments if c.severity == 'error']),
                'warnings': len([c for c in comments if c.severity == 'warning']),
                'info': len([c for c in comments if c.severity == 'info'])
            },
            'issues': [
                {
                    'file': c.file,
                    'line': c.line,
                    'severity': c.severity,
                    'message': c.message,
                    'rule': c.rule
                }
                for c in comments
            ]
        }

        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)

def main():
    bot = CodeReviewBot()
    all_comments = []

    # å®¡æŸ¥æ‰€æœ‰C++æ–‡ä»¶
    for root, dirs, files in os.walk('src/'):
        for file in files:
            if file.endswith(('.cpp', '.h', '.hpp')):
                file_path = os.path.join(root, file)
                comments = bot.review_file(file_path)
                all_comments.extend(comments)

    # ç”ŸæˆæŠ¥å‘Š
    bot.generate_report(all_comments, 'code_review_report.json')

    # æ‰“å°æ‘˜è¦
    print(f"Code review completed. Found {len(all_comments)} issues.")
    for comment in all_comments[:10]:  # æ˜¾ç¤ºå‰10ä¸ªé—®é¢˜
        print(f"{comment.severity.upper()}: {comment.file}:{comment.line} - {comment.message}")

if __name__ == "__main__":
    main()

---

## 5. è‡ªåŠ¨åŒ–æµ‹è¯•ç­–ç•¥

### 5.1 æµ‹è¯•é‡‘å­—å¡”ç†è®º

```
    /\
   /  \     E2E Tests (10%)
  /____\    - ç«¯åˆ°ç«¯æµ‹è¯•
 /      \   - UIæµ‹è¯•
/________\  Integration Tests (20%)
           - é›†æˆæµ‹è¯•
           - APIæµ‹è¯•
___________________
Unit Tests (70%)
- å•å…ƒæµ‹è¯•
- ç»„ä»¶æµ‹è¯•
```

#### å•å…ƒæµ‹è¯•æœ€ä½³å®è·µ
```cpp
// test_example.cpp
#include <gtest/gtest.h>
#include <gmock/gmock.h>

// è¢«æµ‹è¯•çš„ç±»
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    int divide(int a, int b) {
        if (b == 0) throw std::invalid_argument("Division by zero");
        return a / b;
    }
};

// åŸºç¡€å•å…ƒæµ‹è¯•
class CalculatorTest : public ::testing::Test {
protected:
    void SetUp() override {
        calculator = std::make_unique<Calculator>();
    }

    void TearDown() override {
        calculator.reset();
    }

    std::unique_ptr<Calculator> calculator;
};

TEST_F(CalculatorTest, AddPositiveNumbers) {
    EXPECT_EQ(calculator->add(2, 3), 5);
}

TEST_F(CalculatorTest, AddNegativeNumbers) {
    EXPECT_EQ(calculator->add(-2, -3), -5);
}

TEST_F(CalculatorTest, DivideByZeroThrowsException) {
    EXPECT_THROW(calculator->divide(10, 0), std::invalid_argument);
}

// å‚æ•°åŒ–æµ‹è¯•
class CalculatorParameterizedTest : public ::testing::TestWithParam<std::tuple<int, int, int>> {
protected:
    Calculator calculator;
};

TEST_P(CalculatorParameterizedTest, AddNumbers) {
    auto [a, b, expected] = GetParam();
    EXPECT_EQ(calculator.add(a, b), expected);
}

INSTANTIATE_TEST_SUITE_P(
    AdditionTests,
    CalculatorParameterizedTest,
    ::testing::Values(
        std::make_tuple(1, 2, 3),
        std::make_tuple(-1, 1, 0),
        std::make_tuple(0, 0, 0),
        std::make_tuple(100, -50, 50)
    )
);

// Mockå¯¹è±¡æµ‹è¯•
class DatabaseInterface {
public:
    virtual ~DatabaseInterface() = default;
    virtual bool save(const std::string& data) = 0;
    virtual std::string load(const std::string& key) = 0;
};

class MockDatabase : public DatabaseInterface {
public:
    MOCK_METHOD(bool, save, (const std::string& data), (override));
    MOCK_METHOD(std::string, load, (const std::string& key), (override));
};

class UserService {
private:
    std::unique_ptr<DatabaseInterface> database;

public:
    UserService(std::unique_ptr<DatabaseInterface> db) : database(std::move(db)) {}

    bool saveUser(const std::string& userData) {
        return database->save(userData);
    }

    std::string getUser(const std::string& userId) {
        return database->load(userId);
    }
};

TEST(UserServiceTest, SaveUserCallsDatabase) {
    auto mockDb = std::make_unique<MockDatabase>();
    EXPECT_CALL(*mockDb, save("user_data"))
        .Times(1)
        .WillOnce(::testing::Return(true));

    UserService service(std::move(mockDb));
    EXPECT_TRUE(service.saveUser("user_data"));
}
```

### 5.2 æµ‹è¯•è¦†ç›–ç‡åˆ†æ

#### GCOV + LCOVé…ç½®
```cmake
# CMakeLists.txt
option(ENABLE_COVERAGE "Enable coverage reporting" OFF)

if(ENABLE_COVERAGE)
    if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage")
        set(CMAKE_LINKER_FLAGS "${CMAKE_LINKER_FLAGS} --coverage")

        find_program(LCOV_PATH lcov)
        find_program(GENHTML_PATH genhtml)

        if(LCOV_PATH AND GENHTML_PATH)
            add_custom_target(coverage
                COMMAND ${LCOV_PATH} --directory . --capture --output-file coverage.info
                COMMAND ${LCOV_PATH} --remove coverage.info '/usr/*' --output-file coverage.info
                COMMAND ${LCOV_PATH} --list coverage.info
                COMMAND ${GENHTML_PATH} -o coverage coverage.info
                WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
                COMMENT "Generating code coverage report"
            )
        endif()
    endif()
endif()
```

#### è¦†ç›–ç‡æŠ¥å‘Šè„šæœ¬
```bash
#!/bin/bash
# generate_coverage.sh

set -e

BUILD_DIR="build"
COVERAGE_DIR="coverage_report"

# æ¸…ç†ä¹‹å‰çš„è¦†ç›–ç‡æ•°æ®
find . -name "*.gcda" -delete
find . -name "*.gcno" -delete
rm -rf $COVERAGE_DIR

# é‡æ–°æ„å»ºé¡¹ç›®
mkdir -p $BUILD_DIR
cd $BUILD_DIR
cmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON
make -j$(nproc)

# è¿è¡Œæµ‹è¯•
ctest --output-on-failure

# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
lcov --capture --directory . --output-file coverage.info
lcov --remove coverage.info '/usr/*' '*/tests/*' '*/third_party/*' --output-file coverage_filtered.info
lcov --list coverage_filtered.info

# ç”ŸæˆHTMLæŠ¥å‘Š
genhtml coverage_filtered.info --output-directory ../$COVERAGE_DIR

echo "Coverage report generated in $COVERAGE_DIR/index.html"

# æ£€æŸ¥è¦†ç›–ç‡é˜ˆå€¼
COVERAGE=$(lcov --summary coverage_filtered.info | grep "lines" | grep -o '[0-9.]*%' | head -1 | sed 's/%//')
THRESHOLD=80

if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
    echo "Coverage $COVERAGE% is below threshold $THRESHOLD%"
    exit 1
else
    echo "Coverage $COVERAGE% meets threshold $THRESHOLD%"
fi
```

### 5.3 æ€§èƒ½æµ‹è¯•æ¡†æ¶

#### Google Benchmarkä½¿ç”¨
```cpp
// benchmark_example.cpp
#include <benchmark/benchmark.h>
#include <vector>
#include <algorithm>
#include <random>

// åŸºç¡€æ€§èƒ½æµ‹è¯•
static void BM_VectorPushBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> v;
        for (int i = 0; i < state.range(0); ++i) {
            v.push_back(i);
        }
    }
}
BENCHMARK(BM_VectorPushBack)->Range(8, 8<<10);

// å†…å­˜ä½¿ç”¨æµ‹è¯•
static void BM_VectorReserve(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> v;
        v.reserve(state.range(0));
        for (int i = 0; i < state.range(0); ++i) {
            v.push_back(i);
        }
    }
}
BENCHMARK(BM_VectorReserve)->Range(8, 8<<10);

// ç®—æ³•æ€§èƒ½æ¯”è¾ƒ
static void BM_SortStd(benchmark::State& state) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 1000000);

    for (auto _ : state) {
        state.PauseTiming();
        std::vector<int> data(state.range(0));
        std::generate(data.begin(), data.end(), [&]() { return dis(gen); });
        state.ResumeTiming();

        std::sort(data.begin(), data.end());
    }
}
BENCHMARK(BM_SortStd)->Range(1<<10, 1<<18);

// è‡ªå®šä¹‰è®¡æ•°å™¨
static void BM_CustomCounters(benchmark::State& state) {
    size_t items_processed = 0;
    for (auto _ : state) {
        // æ¨¡æ‹Ÿå¤„ç†
        items_processed += state.range(0);
    }
    state.counters["items_per_second"] = benchmark::Counter(
        items_processed, benchmark::Counter::kIsRate);
}
BENCHMARK(BM_CustomCounters)->Range(1<<10, 1<<20);

BENCHMARK_MAIN();
```

---

## 6. æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²

### 6.1 GitHub Actionså®Œæ•´å·¥ä½œæµ

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  BUILD_TYPE: Release

jobs:
  code-quality:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy cppcheck

    - name: Run static analysis
      run: |
        find src/ -name "*.cpp" -o -name "*.h" | xargs clang-tidy
        cppcheck --enable=all --error-exitcode=1 src/

    - name: Check code formatting
      run: |
        find src/ -name "*.cpp" -o -name "*.h" | xargs clang-format --dry-run --Werror

  build-and-test:
    needs: code-quality
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        compiler: [gcc, clang]
        exclude:
          - os: windows-latest
            compiler: gcc

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v3

    - name: Setup C++
      uses: aminya/setup-cpp@v1
      with:
        compiler: ${{ matrix.compiler }}
        vcvarsall: ${{ contains(matrix.os, 'windows') }}
        cmake: true
        ninja: true
        ccache: true

    - name: Configure CMake
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=$BUILD_TYPE -DBUILD_TESTS=ON

    - name: Build
      run: cmake --build build --config $BUILD_TYPE --parallel

    - name: Test
      working-directory: build
      run: ctest -C $BUILD_TYPE --output-on-failure

    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: test-results-${{ matrix.os }}-${{ matrix.compiler }}
        path: build/Testing/

  coverage:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y lcov

    - name: Configure CMake with coverage
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON -DBUILD_TESTS=ON

    - name: Build and test
      run: |
        cmake --build build --parallel
        cd build && ctest --output-on-failure

    - name: Generate coverage report
      run: |
        lcov --capture --directory build --output-file coverage.info
        lcov --remove coverage.info '/usr/*' '*/tests/*' --output-file coverage_filtered.info

    - name: Upload to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: coverage_filtered.info

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: cpp

    - name: Build for analysis
      run: |
        cmake -B build -DCMAKE_BUILD_TYPE=Debug
        cmake --build build --parallel

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

  package:
    needs: [build-and-test, coverage]
    if: github.event_name == 'release'
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v3

    - name: Configure CMake
      run: cmake -B build -DCMAKE_BUILD_TYPE=Release

    - name: Build
      run: cmake --build build --config Release --parallel

    - name: Package
      run: |
        cd build
        cpack

    - name: Upload packages
      uses: actions/upload-artifact@v3
      with:
        name: packages-${{ matrix.os }}
        path: build/*.tar.gz

  deploy:
    needs: package
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    steps:
    - name: Download packages
      uses: actions/download-artifact@v3

    - name: Release
      uses: softprops/action-gh-release@v1
      with:
        files: packages-*/*

---

## 7. AIè¾…åŠ©å¼€å‘

### 7.1 AIå·¥å…·ç”Ÿæ€ç³»ç»Ÿ

#### ä»£ç ç”Ÿæˆå·¥å…·å¯¹æ¯”

| å·¥å…· | ç±»å‹ | ä¼˜åŠ¿ | é€‚ç”¨åœºæ™¯ | æˆæœ¬ |
|------|------|------|----------|------|
| **GitHub Copilot** | IDEæ’ä»¶ | ä¸Šä¸‹æ–‡ç†è§£å¥½ã€å®æ—¶å»ºè®® | æ—¥å¸¸ç¼–ç  | $10/æœˆ |
| **ChatGPT/GPT-4** | å¯¹è¯å¼ | è§£é‡Šèƒ½åŠ›å¼ºã€å¤šè¯­è¨€ | ä»£ç å®¡æŸ¥ã€å­¦ä¹  | $20/æœˆ |
| **Claude** | å¯¹è¯å¼ | é•¿æ–‡æœ¬å¤„ç†ã€å®‰å…¨æ€§ | æ¶æ„è®¾è®¡ã€æ–‡æ¡£ | æŒ‰ä½¿ç”¨é‡ |
| **Tabnine** | IDEæ’ä»¶ | æœ¬åœ°éƒ¨ç½²ã€éšç§ä¿æŠ¤ | ä¼ä¸šç¯å¢ƒ | $12/æœˆ |
| **Amazon CodeWhisperer** | IDEæ’ä»¶ | AWSé›†æˆã€å…è´¹å±‚ | äº‘å¼€å‘ | å…è´¹/ä»˜è´¹ |
| **Replit Ghostwriter** | åœ¨çº¿IDE | åä½œç¼–ç¨‹ | åŸå‹å¼€å‘ | $7/æœˆ |

#### AIè¾…åŠ©ç¼–ç¨‹æœ€ä½³å®è·µ

**1. æç¤ºå·¥ç¨‹ï¼ˆPrompt Engineeringï¼‰**
```
# å¥½çš„æç¤ºç¤ºä¾‹
"è¯·å¸®æˆ‘å®ç°ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼ï¼Œä½¿ç”¨C++17æ ‡å‡†ï¼ŒåŒ…å«ä»¥ä¸‹è¦æ±‚ï¼š
1. æ‡’åŠ è½½åˆå§‹åŒ–
2. çº¿ç¨‹å®‰å…¨
3. å¼‚å¸¸å®‰å…¨
4. ç¦æ­¢æ‹·è´å’Œç§»åŠ¨
5. åŒ…å«å®Œæ•´çš„æ³¨é‡Šå’Œä½¿ç”¨ç¤ºä¾‹"

# ä¸å¥½çš„æç¤ºç¤ºä¾‹
"å†™ä¸ªå•ä¾‹"
```

**2. ä»£ç å®¡æŸ¥æç¤ºæ¨¡æ¿**
```
è¯·å®¡æŸ¥ä»¥ä¸‹C++ä»£ç ï¼Œé‡ç‚¹å…³æ³¨ï¼š
1. å†…å­˜å®‰å…¨ï¼ˆå†…å­˜æ³„æ¼ã€é‡æŒ‡é’ˆï¼‰
2. çº¿ç¨‹å®‰å…¨
3. å¼‚å¸¸å®‰å…¨
4. æ€§èƒ½é—®é¢˜
5. ä»£ç é£æ ¼å’Œå¯è¯»æ€§
6. SOLIDåŸåˆ™éµå¾ªæƒ…å†µ

ä»£ç ï¼š
[ç²˜è´´ä»£ç ]

è¯·æä¾›å…·ä½“çš„æ”¹è¿›å»ºè®®å’Œä¿®æ”¹åçš„ä»£ç ã€‚
```

### 7.2 AIè¾…åŠ©ä»£ç ç”Ÿæˆå®ä¾‹

#### æ™ºèƒ½ä»£ç è¡¥å…¨é…ç½®
```json
// VS Code settings.json
{
    "github.copilot.enable": {
        "*": true,
        "yaml": false,
        "plaintext": false,
        "markdown": false
    },
    "github.copilot.inlineSuggest.enable": true,
    "github.copilot.suggestions.count": 3,
    "tabnine.experimentalAutoImports": true,
    "tabnine.disableLineRegex": [
        "^\\s*//",
        "^\\s*#",
        "^\\s*\\*"
    ]
}
```

#### AIç”Ÿæˆçš„è®¾è®¡æ¨¡å¼ç¤ºä¾‹
```cpp
// AIè¾…åŠ©ç”Ÿæˆçš„è§‚å¯Ÿè€…æ¨¡å¼å®ç°
#include <vector>
#include <memory>
#include <algorithm>
#include <functional>

// è§‚å¯Ÿè€…æ¥å£
template<typename EventType>
class Observer {
public:
    virtual ~Observer() = default;
    virtual void onNotify(const EventType& event) = 0;
};

// ä¸»é¢˜/è¢«è§‚å¯Ÿè€…
template<typename EventType>
class Subject {
private:
    std::vector<std::weak_ptr<Observer<EventType>>> observers;

public:
    void attach(std::shared_ptr<Observer<EventType>> observer) {
        observers.push_back(observer);
    }

    void detach(std::shared_ptr<Observer<EventType>> observer) {
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [&observer](const std::weak_ptr<Observer<EventType>>& weak_obs) {
                    return weak_obs.expired() || weak_obs.lock() == observer;
                }),
            observers.end()
        );
    }

    void notify(const EventType& event) {
        // æ¸…ç†è¿‡æœŸçš„è§‚å¯Ÿè€…
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [](const std::weak_ptr<Observer<EventType>>& weak_obs) {
                    return weak_obs.expired();
                }),
            observers.end()
        );

        // é€šçŸ¥æ‰€æœ‰æœ‰æ•ˆçš„è§‚å¯Ÿè€…
        for (const auto& weak_obs : observers) {
            if (auto obs = weak_obs.lock()) {
                obs->onNotify(event);
            }
        }
    }
};

// ä½¿ç”¨ç¤ºä¾‹
struct UserEvent {
    std::string username;
    std::string action;
};

class UserLogger : public Observer<UserEvent> {
public:
    void onNotify(const UserEvent& event) override {
        std::cout << "Log: User " << event.username
                  << " performed " << event.action << std::endl;
    }
};

class UserAnalytics : public Observer<UserEvent> {
public:
    void onNotify(const UserEvent& event) override {
        // å‘é€åˆ†ææ•°æ®
        std::cout << "Analytics: Tracking " << event.action
                  << " for user " << event.username << std::endl;
    }
};
```

### 7.3 AIè¾…åŠ©æµ‹è¯•ç”Ÿæˆ

#### è‡ªåŠ¨åŒ–æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆ
```python
#!/usr/bin/env python3
"""
AIè¾…åŠ©æµ‹è¯•ç”¨ä¾‹ç”Ÿæˆå™¨
"""

import openai
import re
from typing import List, Dict

class AITestGenerator:
    def __init__(self, api_key: str):
        openai.api_key = api_key

    def generate_test_cases(self, function_code: str, function_name: str) -> str:
        """ä½¿ç”¨AIç”Ÿæˆæµ‹è¯•ç”¨ä¾‹"""
        prompt = f"""
        è¯·ä¸ºä»¥ä¸‹C++å‡½æ•°ç”Ÿæˆå®Œæ•´çš„Google Testæµ‹è¯•ç”¨ä¾‹ï¼š

        å‡½æ•°ä»£ç ï¼š
        {function_code}

        è¦æ±‚ï¼š
        1. åŒ…å«æ­£å¸¸æƒ…å†µæµ‹è¯•
        2. åŒ…å«è¾¹ç•Œæ¡ä»¶æµ‹è¯•
        3. åŒ…å«å¼‚å¸¸æƒ…å†µæµ‹è¯•
        4. ä½¿ç”¨å‚æ•°åŒ–æµ‹è¯•ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
        5. åŒ…å«æ€§èƒ½æµ‹è¯•ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
        6. éµå¾ªAAAæ¨¡å¼ï¼ˆArrange, Act, Assertï¼‰
        7. æµ‹è¯•å‘½åè¦æ¸…æ™°æè¿°æµ‹è¯•æ„å›¾

        è¯·ç”Ÿæˆå®Œæ•´çš„æµ‹è¯•æ–‡ä»¶ï¼ŒåŒ…å«å¿…è¦çš„å¤´æ–‡ä»¶å’Œæµ‹è¯•ç±»ã€‚
        """

        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=2000,
            temperature=0.3
        )

        return response.choices[0].message.content

    def generate_mock_objects(self, interface_code: str) -> str:
        """ç”ŸæˆMockå¯¹è±¡"""
        prompt = f"""
        è¯·ä¸ºä»¥ä¸‹C++æ¥å£ç”ŸæˆGoogle Mockçš„Mockç±»ï¼š

        æ¥å£ä»£ç ï¼š
        {interface_code}

        è¦æ±‚ï¼š
        1. ä½¿ç”¨MOCK_METHODå®
        2. åŒ…å«å¿…è¦çš„å¤´æ–‡ä»¶
        3. æä¾›ä½¿ç”¨ç¤ºä¾‹
        4. è€ƒè™‘constæ–¹æ³•å’Œé‡è½½æ–¹æ³•
        """

        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1500,
            temperature=0.3
        )

        return response.choices[0].message.content

    def analyze_coverage_gaps(self, coverage_report: str, source_code: str) -> str:
        """åˆ†æè¦†ç›–ç‡ç¼ºå£å¹¶å»ºè®®æµ‹è¯•"""
        prompt = f"""
        åŸºäºä»¥ä¸‹è¦†ç›–ç‡æŠ¥å‘Šå’Œæºä»£ç ï¼Œè¯·åˆ†ææµ‹è¯•è¦†ç›–ç‡ç¼ºå£å¹¶å»ºè®®éœ€è¦æ·»åŠ çš„æµ‹è¯•ï¼š

        è¦†ç›–ç‡æŠ¥å‘Šï¼š
        {coverage_report}

        æºä»£ç ï¼š
        {source_code}

        è¯·æä¾›ï¼š
        1. æœªè¦†ç›–ä»£ç çš„åˆ†æ
        2. å»ºè®®çš„æµ‹è¯•ç”¨ä¾‹
        3. æµ‹è¯•ä¼˜å…ˆçº§æ’åº
        """

        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1500,
            temperature=0.3
        )

        return response.choices[0].message.content

# ä½¿ç”¨ç¤ºä¾‹
def main():
    generator = AITestGenerator("your-openai-api-key")

    function_code = """
    class Calculator {
    public:
        int divide(int a, int b) {
            if (b == 0) {
                throw std::invalid_argument("Division by zero");
            }
            return a / b;
        }
    };
    """

    test_cases = generator.generate_test_cases(function_code, "divide")
    print("Generated test cases:")
    print(test_cases)

if __name__ == "__main__":
    main()
```

### 7.4 AIè¾…åŠ©ä»£ç é‡æ„

#### é‡æ„å»ºè®®ç”Ÿæˆå™¨
```python
class AIRefactoringAssistant:
    def __init__(self, api_key: str):
        openai.api_key = api_key

    def suggest_refactoring(self, code: str, issues: List[str]) -> str:
        """å»ºè®®é‡æ„æ–¹æ¡ˆ"""
        issues_text = "\n".join(f"- {issue}" for issue in issues)

        prompt = f"""
        è¯·åˆ†æä»¥ä¸‹C++ä»£ç å¹¶æä¾›é‡æ„å»ºè®®ï¼š

        ä»£ç ï¼š
        {code}

        å·²è¯†åˆ«çš„é—®é¢˜ï¼š
        {issues_text}

        è¯·æä¾›ï¼š
        1. è¯¦ç»†çš„é‡æ„è®¡åˆ’
        2. é‡æ„åçš„ä»£ç 
        3. é‡æ„çš„å¥½å¤„
        4. æ½œåœ¨çš„é£é™©
        5. é‡æ„æ­¥éª¤çš„ä¼˜å…ˆçº§
        """

        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=2500,
            temperature=0.3
        )

        return response.choices[0].message.content

    def extract_design_patterns(self, code: str) -> str:
        """è¯†åˆ«å’Œå»ºè®®è®¾è®¡æ¨¡å¼"""
        prompt = f"""
        è¯·åˆ†æä»¥ä¸‹ä»£ç ï¼Œè¯†åˆ«å¯ä»¥åº”ç”¨çš„è®¾è®¡æ¨¡å¼ï¼š

        {code}

        è¯·æä¾›ï¼š
        1. å½“å‰ä»£ç çš„é—®é¢˜
        2. é€‚ç”¨çš„è®¾è®¡æ¨¡å¼
        3. åº”ç”¨è®¾è®¡æ¨¡å¼åçš„ä»£ç 
        4. è®¾è®¡æ¨¡å¼çš„ä¼˜ç¼ºç‚¹
        """

        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=2000,
            temperature=0.3
        )

        return response.choices[0].message.content

---

## 8. ä»£ç é‡æ„æŠ€æœ¯

### 8.1 é‡æ„åŸåˆ™ä¸æ—¶æœº

#### é‡æ„çš„ä¿¡å·ï¼ˆCode Smellsï¼‰

**1. é•¿æ–¹æ³•ï¼ˆLong Methodï¼‰**
```cpp
// âŒ é—®é¢˜ä»£ç 
class OrderProcessor {
public:
    void processOrder(const Order& order) {
        // éªŒè¯è®¢å• (20è¡Œä»£ç )
        if (order.items.empty()) {
            throw std::invalid_argument("Empty order");
        }
        for (const auto& item : order.items) {
            if (item.quantity <= 0) {
                throw std::invalid_argument("Invalid quantity");
            }
            if (item.price < 0) {
                throw std::invalid_argument("Invalid price");
            }
        }

        // è®¡ç®—æ€»ä»· (15è¡Œä»£ç )
        double total = 0;
        for (const auto& item : order.items) {
            total += item.price * item.quantity;
        }
        if (order.discount > 0) {
            total *= (1.0 - order.discount);
        }

        // æ£€æŸ¥åº“å­˜ (25è¡Œä»£ç )
        for (const auto& item : order.items) {
            if (!inventory.hasStock(item.id, item.quantity)) {
                throw std::runtime_error("Insufficient stock");
            }
        }

        // å¤„ç†æ”¯ä»˜ (30è¡Œä»£ç )
        // ... æ›´å¤šä»£ç 

        // æ›´æ–°åº“å­˜ (20è¡Œä»£ç )
        // ... æ›´å¤šä»£ç 

        // å‘é€é€šçŸ¥ (15è¡Œä»£ç )
        // ... æ›´å¤šä»£ç 
    }
};

// âœ… é‡æ„å
class OrderProcessor {
public:
    void processOrder(const Order& order) {
        validateOrder(order);
        double total = calculateTotal(order);
        checkInventory(order);
        processPayment(order, total);
        updateInventory(order);
        sendNotifications(order);
    }

private:
    void validateOrder(const Order& order) {
        if (order.items.empty()) {
            throw std::invalid_argument("Empty order");
        }

        for (const auto& item : order.items) {
            validateItem(item);
        }
    }

    void validateItem(const OrderItem& item) {
        if (item.quantity <= 0) {
            throw std::invalid_argument("Invalid quantity");
        }
        if (item.price < 0) {
            throw std::invalid_argument("Invalid price");
        }
    }

    double calculateTotal(const Order& order) {
        double total = 0;
        for (const auto& item : order.items) {
            total += item.price * item.quantity;
        }
        return applyDiscount(total, order.discount);
    }

    double applyDiscount(double total, double discount) {
        return discount > 0 ? total * (1.0 - discount) : total;
    }

    // ... å…¶ä»–ç§æœ‰æ–¹æ³•
};
```

**2. å¤§ç±»ï¼ˆLarge Classï¼‰**
```cpp
// âŒ é—®é¢˜ä»£ç 
class User {
private:
    // ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
    std::string name, email, phone;

    // åœ°å€ä¿¡æ¯
    std::string street, city, country, zipCode;

    // æ”¯ä»˜ä¿¡æ¯
    std::string creditCardNumber, expiryDate, cvv;

    // åå¥½è®¾ç½®
    std::string language, timezone, theme;

    // ç»Ÿè®¡ä¿¡æ¯
    int loginCount, orderCount;
    std::chrono::system_clock::time_point lastLogin;

public:
    // ç”¨æˆ·ç®¡ç†æ–¹æ³•
    void updateProfile();
    void changePassword();

    // åœ°å€ç®¡ç†æ–¹æ³•
    void updateAddress();
    void validateAddress();

    // æ”¯ä»˜ç®¡ç†æ–¹æ³•
    void addPaymentMethod();
    void validatePayment();

    // åå¥½ç®¡ç†æ–¹æ³•
    void updatePreferences();
    void resetPreferences();

    // ç»Ÿè®¡æ–¹æ³•
    void updateLoginStats();
    void generateReport();
};

// âœ… é‡æ„å - ä½¿ç”¨ç»„åˆ
class User {
private:
    UserProfile profile;
    Address address;
    PaymentInfo payment;
    UserPreferences preferences;
    UserStatistics statistics;

public:
    UserProfile& getProfile() { return profile; }
    Address& getAddress() { return address; }
    PaymentInfo& getPayment() { return payment; }
    UserPreferences& getPreferences() { return preferences; }
    UserStatistics& getStatistics() { return statistics; }
};

class UserProfile {
private:
    std::string name, email, phone;

public:
    void update(const std::string& name, const std::string& email);
    void changePassword(const std::string& newPassword);
    bool validate() const;
};

class Address {
private:
    std::string street, city, country, zipCode;

public:
    void update(const std::string& street, const std::string& city);
    bool validate() const;
};
```

### 8.2 è‡ªåŠ¨åŒ–é‡æ„å·¥å…·

#### Clang-Tidyé‡æ„è§„åˆ™
```yaml
# .clang-tidy
Checks: >
  modernize-*,
  readability-*,
  performance-*,
  bugprone-*

CheckOptions:
  - key: modernize-use-auto.MinTypeNameLength
    value: 5
  - key: modernize-use-nullptr.NullMacros
    value: 'NULL'
  - key: readability-identifier-naming.ClassCase
    value: CamelCase
  - key: readability-identifier-naming.FunctionCase
    value: camelCase
```

#### è‡ªåŠ¨é‡æ„è„šæœ¬
```bash
#!/bin/bash
# auto_refactor.sh

# åº”ç”¨ç°ä»£åŒ–é‡æ„
clang-tidy -fix -checks="modernize-*" src/**/*.cpp

# åº”ç”¨æ€§èƒ½ä¼˜åŒ–
clang-tidy -fix -checks="performance-*" src/**/*.cpp

# åº”ç”¨å¯è¯»æ€§æ”¹è¿›
clang-tidy -fix -checks="readability-*" src/**/*.cpp

# æ ¼å¼åŒ–ä»£ç 
find src/ -name "*.cpp" -o -name "*.h" | xargs clang-format -i

echo "Automatic refactoring completed"

---

## 9. æ€§èƒ½ä¼˜åŒ–æ–¹æ³•

### 9.1 æ€§èƒ½åˆ†ææ–¹æ³•è®º

#### æ€§èƒ½ä¼˜åŒ–æµç¨‹
```
1. æµ‹é‡ (Measure)
   â†“
2. åˆ†æ (Analyze)
   â†“
3. ä¼˜åŒ– (Optimize)
   â†“
4. éªŒè¯ (Verify)
   â†“
5. é‡å¤ (Repeat)
```

#### CPUæ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

**1. ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„**
```cpp
// âŒ ç¼“å­˜ä¸å‹å¥½
struct BadParticle {
    float x, y, z;           // ä½ç½® (12 bytes)
    char padding1[4];        // å¡«å……
    double mass;             // è´¨é‡ (8 bytes)
    char padding2[8];        // å¡«å……
    float vx, vy, vz;        // é€Ÿåº¦ (12 bytes)
    char padding3[4];        // å¡«å……
    int id;                  // ID (4 bytes)
    char padding4[12];       // å¡«å……
    // æ€»è®¡: 64 bytesï¼Œç¼“å­˜åˆ©ç”¨ç‡ä½
};

// âœ… ç¼“å­˜å‹å¥½
struct GoodParticle {
    float x, y, z;           // ä½ç½® (12 bytes)
    float vx, vy, vz;        // é€Ÿåº¦ (12 bytes)
    double mass;             // è´¨é‡ (8 bytes)
    int id;                  // ID (4 bytes)
    char padding[4];         // å¯¹é½å¡«å……
    // æ€»è®¡: 40 bytesï¼Œæ›´å¥½çš„ç¼“å­˜åˆ©ç”¨ç‡
};

// æ•°æ®ç»“æ„åˆ†ç¦» (SoA vs AoS)
class ParticleSystemAoS {
    std::vector<GoodParticle> particles;

public:
    void updatePositions(float dt) {
        for (auto& p : particles) {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.z += p.vz * dt;
        }
    }
};

class ParticleSystemSoA {
    std::vector<float> x, y, z;     // ä½ç½®
    std::vector<float> vx, vy, vz;  // é€Ÿåº¦
    std::vector<double> mass;       // è´¨é‡
    std::vector<int> id;            // ID

public:
    void updatePositions(float dt) {
        const size_t count = x.size();
        for (size_t i = 0; i < count; ++i) {
            x[i] += vx[i] * dt;
            y[i] += vy[i] * dt;
            z[i] += vz[i] * dt;
        }
    }
};
```

**2. SIMDä¼˜åŒ–**
```cpp
#include <immintrin.h>

// æ ‡é‡ç‰ˆæœ¬
void add_arrays_scalar(const float* a, const float* b, float* result, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        result[i] = a[i] + b[i];
    }
}

// AVX2 SIMDç‰ˆæœ¬
void add_arrays_simd(const float* a, const float* b, float* result, size_t size) {
    const size_t simd_size = size - (size % 8);

    // SIMDå¤„ç†
    for (size_t i = 0; i < simd_size; i += 8) {
        __m256 va = _mm256_load_ps(&a[i]);
        __m256 vb = _mm256_load_ps(&b[i]);
        __m256 vresult = _mm256_add_ps(va, vb);
        _mm256_store_ps(&result[i], vresult);
    }

    // å¤„ç†å‰©ä½™å…ƒç´ 
    for (size_t i = simd_size; i < size; ++i) {
        result[i] = a[i] + b[i];
    }
}

// é€šç”¨SIMDåŒ…è£…å™¨
template<typename T>
class SIMDArray {
private:
    alignas(32) std::vector<T> data;

public:
    SIMDArray(size_t size) : data(size) {}

    void add(const SIMDArray& other, SIMDArray& result) {
        if constexpr (std::is_same_v<T, float>) {
            add_arrays_simd(data.data(), other.data.data(),
                          result.data.data(), data.size());
        } else {
            add_arrays_scalar(data.data(), other.data.data(),
                            result.data.data(), data.size());
        }
    }
};
```

**3. åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–**
```cpp
// âŒ åˆ†æ”¯é¢„æµ‹å›°éš¾
int process_data_bad(const std::vector<int>& data) {
    int sum = 0;
    for (int value : data) {
        if (value > 50) {  // éšæœºåˆ†æ”¯
            sum += value * 2;
        } else {
            sum += value;
        }
    }
    return sum;
}

// âœ… å‡å°‘åˆ†æ”¯
int process_data_good(const std::vector<int>& data) {
    int sum = 0;
    for (int value : data) {
        // ä½¿ç”¨æ¡ä»¶ç§»åŠ¨è€Œä¸æ˜¯åˆ†æ”¯
        int multiplier = (value > 50) ? 2 : 1;
        sum += value * multiplier;
    }
    return sum;
}

// âœ… åˆ†æ”¯æç¤º
int process_data_with_hints(const std::vector<int>& data) {
    int sum = 0;
    for (int value : data) {
        if ([[likely]] value <= 50) {  // C++20åˆ†æ”¯æç¤º
            sum += value;
        } else {
            sum += value * 2;
        }
    }
    return sum;
}
```

### 9.2 å†…å­˜ä¼˜åŒ–æŠ€æœ¯

#### å†…å­˜æ± å®ç°
```cpp
template<typename T, size_t BlockSize = 4096>
class MemoryPool {
private:
    struct Block {
        alignas(T) char data[BlockSize];
        Block* next;
    };

    Block* current_block;
    char* current_pos;
    char* current_end;
    std::vector<std::unique_ptr<Block>> blocks;

public:
    MemoryPool() : current_block(nullptr), current_pos(nullptr), current_end(nullptr) {
        allocate_new_block();
    }

    template<typename... Args>
    T* construct(Args&&... args) {
        void* ptr = allocate();
        return new(ptr) T(std::forward<Args>(args)...);
    }

    void destroy(T* ptr) {
        ptr->~T();
        // æ³¨æ„ï¼šè¿™é‡Œä¸é‡Šæ”¾å†…å­˜ï¼Œå†…å­˜åœ¨æ± é”€æ¯æ—¶ç»Ÿä¸€é‡Šæ”¾
    }

private:
    void* allocate() {
        const size_t size = sizeof(T);
        const size_t alignment = alignof(T);

        // å¯¹é½å½“å‰ä½ç½®
        char* aligned_pos = reinterpret_cast<char*>(
            (reinterpret_cast<uintptr_t>(current_pos) + alignment - 1) & ~(alignment - 1)
        );

        if (aligned_pos + size > current_end) {
            allocate_new_block();
            aligned_pos = current_pos;
        }

        current_pos = aligned_pos + size;
        return aligned_pos;
    }

    void allocate_new_block() {
        auto block = std::make_unique<Block>();
        current_block = block.get();
        current_pos = block->data;
        current_end = block->data + BlockSize;
        blocks.push_back(std::move(block));
    }
};

// ä½¿ç”¨ç¤ºä¾‹
class GameObject {
public:
    float x, y, z;
    int health;

    GameObject(float x, float y, float z, int health)
        : x(x), y(y), z(z), health(health) {}
};

void memory_pool_example() {
    MemoryPool<GameObject> pool;

    // å¿«é€Ÿåˆ†é…å¯¹è±¡
    std::vector<GameObject*> objects;
    for (int i = 0; i < 1000; ++i) {
        objects.push_back(pool.construct(i * 1.0f, i * 2.0f, i * 3.0f, 100));
    }

    // é”€æ¯å¯¹è±¡
    for (auto* obj : objects) {
        pool.destroy(obj);
    }
    // å†…å­˜åœ¨poolææ„æ—¶è‡ªåŠ¨é‡Šæ”¾
}
```

#### æ™ºèƒ½æŒ‡é’ˆä¼˜åŒ–
```cpp
// âŒ è¿‡åº¦ä½¿ç”¨shared_ptr
class BadDesign {
    std::shared_ptr<ExpensiveResource> resource;

public:
    void process() {
        auto local_copy = resource;  // ä¸å¿…è¦çš„å¼•ç”¨è®¡æ•°æ“ä½œ
        local_copy->doSomething();
    }
};

// âœ… åˆç†ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
class GoodDesign {
    std::unique_ptr<ExpensiveResource> resource;  // ç‹¬å æ‰€æœ‰æƒ

public:
    void process() {
        resource->doSomething();  // ç›´æ¥ä½¿ç”¨ï¼Œæ— å¼•ç”¨è®¡æ•°å¼€é”€
    }

    // åªåœ¨éœ€è¦å…±äº«æ—¶æ‰ä½¿ç”¨shared_ptr
    std::shared_ptr<ExpensiveResource> getSharedResource() {
        return std::shared_ptr<ExpensiveResource>(std::move(resource));
    }
};

// è‡ªå®šä¹‰åˆ é™¤å™¨ä¼˜åŒ–
class ResourceManager {
private:
    MemoryPool<Resource> pool;

public:
    std::unique_ptr<Resource, std::function<void(Resource*)>>
    createResource() {
        auto deleter = [this](Resource* ptr) {
            pool.destroy(ptr);
        };

        return std::unique_ptr<Resource, std::function<void(Resource*)>>(
            pool.construct(), deleter
        );
    }
};
```

### 9.3 å¹¶å‘æ€§èƒ½ä¼˜åŒ–

#### æ— é”æ•°æ®ç»“æ„
```cpp
// æ— é”é˜Ÿåˆ—å®ç°
template<typename T>
class LockFreeQueue {
private:
    struct Node {
        std::atomic<T*> data;
        std::atomic<Node*> next;

        Node() : data(nullptr), next(nullptr) {}
    };

    std::atomic<Node*> head;
    std::atomic<Node*> tail;

public:
    LockFreeQueue() {
        Node* dummy = new Node;
        head.store(dummy);
        tail.store(dummy);
    }

    void enqueue(T item) {
        Node* new_node = new Node;
        T* data = new T(std::move(item));
        new_node->data.store(data);

        while (true) {
            Node* last = tail.load();
            Node* next = last->next.load();

            if (last == tail.load()) {  // ç¡®ä¿tailæ²¡æœ‰è¢«å…¶ä»–çº¿ç¨‹ä¿®æ”¹
                if (next == nullptr) {
                    // å°è¯•é“¾æ¥æ–°èŠ‚ç‚¹
                    if (last->next.compare_exchange_weak(next, new_node)) {
                        break;
                    }
                } else {
                    // å¸®åŠ©å…¶ä»–çº¿ç¨‹æ¨è¿›tail
                    tail.compare_exchange_weak(last, next);
                }
            }
        }

        // æ¨è¿›tail
        tail.compare_exchange_weak(tail.load(), new_node);
    }

    bool dequeue(T& result) {
        while (true) {
            Node* first = head.load();
            Node* last = tail.load();
            Node* next = first->next.load();

            if (first == head.load()) {  // ç¡®ä¿headæ²¡æœ‰è¢«ä¿®æ”¹
                if (first == last) {
                    if (next == nullptr) {
                        return false;  // é˜Ÿåˆ—ä¸ºç©º
                    }
                    // å¸®åŠ©æ¨è¿›tail
                    tail.compare_exchange_weak(last, next);
                } else {
                    if (next == nullptr) {
                        continue;  // ä¸ä¸€è‡´çŠ¶æ€ï¼Œé‡è¯•
                    }

                    // è¯»å–æ•°æ®
                    T* data = next->data.load();
                    if (data == nullptr) {
                        continue;  // æ•°æ®è¿˜æœªè®¾ç½®ï¼Œé‡è¯•
                    }

                    // æ¨è¿›head
                    if (head.compare_exchange_weak(first, next)) {
                        result = *data;
                        delete data;
                        delete first;
                        return true;
                    }
                }
            }
        }
    }
};
```

#### çº¿ç¨‹æ± ä¼˜åŒ–
```cpp
class OptimizedThreadPool {
private:
    std::vector<std::thread> workers;
    std::vector<LockFreeQueue<std::function<void()>>> task_queues;
    std::atomic<bool> stop;
    std::atomic<size_t> next_queue;

public:
    OptimizedThreadPool(size_t num_threads = std::thread::hardware_concurrency())
        : stop(false), next_queue(0) {

        task_queues.resize(num_threads);

        for (size_t i = 0; i < num_threads; ++i) {
            workers.emplace_back([this, i] {
                worker_thread(i);
            });
        }
    }

    template<typename F>
    void submit(F&& task) {
        // è½®è¯¢åˆ†é…ä»»åŠ¡åˆ°ä¸åŒé˜Ÿåˆ—
        size_t queue_index = next_queue.fetch_add(1) % task_queues.size();
        task_queues[queue_index].enqueue(std::forward<F>(task));
    }

private:
    void worker_thread(size_t thread_id) {
        while (!stop.load()) {
            std::function<void()> task;

            // é¦–å…ˆå°è¯•ä»è‡ªå·±çš„é˜Ÿåˆ—è·å–ä»»åŠ¡
            if (task_queues[thread_id].dequeue(task)) {
                task();
                continue;
            }

            // å·¥ä½œçªƒå–ï¼šä»å…¶ä»–é˜Ÿåˆ—çªƒå–ä»»åŠ¡
            bool found_task = false;
            for (size_t i = 1; i < task_queues.size(); ++i) {
                size_t steal_index = (thread_id + i) % task_queues.size();
                if (task_queues[steal_index].dequeue(task)) {
                    task();
                    found_task = true;
                    break;
                }
            }

            if (!found_task) {
                // çŸ­æš‚ä¼‘çœ é¿å…å¿™ç­‰å¾…
                std::this_thread::sleep_for(std::chrono::microseconds(1));
            }
        }
    }
};
```

---

## 10. å®‰å…¨ç¼–ç¨‹å®è·µ

### 10.1 å†…å­˜å®‰å…¨

#### ç¼“å†²åŒºæº¢å‡ºé˜²æŠ¤
```cpp
// âŒ ä¸å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ
void unsafe_string_copy(const char* source) {
    char buffer[100];
    strcpy(buffer, source);  // æ½œåœ¨çš„ç¼“å†²åŒºæº¢å‡º
    printf("%s\n", buffer);
}

// âœ… å®‰å…¨çš„å­—ç¬¦ä¸²æ“ä½œ
void safe_string_copy(const char* source) {
    char buffer[100];
    strncpy(buffer, source, sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0';  // ç¡®ä¿nullç»ˆæ­¢
    printf("%s\n", buffer);
}

// âœ… æ›´å¥½çš„C++æ–¹å¼
void cpp_safe_string_copy(const std::string& source) {
    constexpr size_t max_length = 99;
    std::string safe_string = source.substr(0, max_length);
    std::cout << safe_string << std::endl;
}

// å®‰å…¨çš„ç¼“å†²åŒºç±»
template<size_t Size>
class SafeBuffer {
private:
    std::array<char, Size> buffer;
    size_t current_size = 0;

public:
    bool append(const char* data, size_t length) {
        if (current_size + length >= Size) {
            return false;  // é˜²æ­¢æº¢å‡º
        }

        std::memcpy(buffer.data() + current_size, data, length);
        current_size += length;
        buffer[current_size] = '\0';
        return true;
    }

    const char* c_str() const {
        return buffer.data();
    }

    size_t size() const {
        return current_size;
    }

    size_t capacity() const {
        return Size - 1;  // ä¿ç•™ä¸€ä¸ªå­—èŠ‚ç»™nullç»ˆæ­¢ç¬¦
    }
};
```

#### æ•´æ•°æº¢å‡ºé˜²æŠ¤
```cpp
#include <limits>
#include <stdexcept>

template<typename T>
class SafeInteger {
private:
    T value;

    static void check_add_overflow(T a, T b) {
        if constexpr (std::is_signed_v<T>) {
            if ((b > 0 && a > std::numeric_limits<T>::max() - b) ||
                (b < 0 && a < std::numeric_limits<T>::min() - b)) {
                throw std::overflow_error("Integer addition overflow");
            }
        } else {
            if (a > std::numeric_limits<T>::max() - b) {
                throw std::overflow_error("Integer addition overflow");
            }
        }
    }

    static void check_mul_overflow(T a, T b) {
        if (a == 0 || b == 0) return;

        if constexpr (std::is_signed_v<T>) {
            if (a > 0) {
                if (b > 0 && a > std::numeric_limits<T>::max() / b) {
                    throw std::overflow_error("Integer multiplication overflow");
                }
                if (b < 0 && b < std::numeric_limits<T>::min() / a) {
                    throw std::overflow_error("Integer multiplication overflow");
                }
            } else {
                if (b > 0 && a < std::numeric_limits<T>::min() / b) {
                    throw std::overflow_error("Integer multiplication overflow");
                }
                if (b < 0 && a > std::numeric_limits<T>::max() / b) {
                    throw std::overflow_error("Integer multiplication overflow");
                }
            }
        } else {
            if (a > std::numeric_limits<T>::max() / b) {
                throw std::overflow_error("Integer multiplication overflow");
            }
        }
    }

public:
    SafeInteger(T val = 0) : value(val) {}

    SafeInteger operator+(const SafeInteger& other) const {
        check_add_overflow(value, other.value);
        return SafeInteger(value + other.value);
    }

    SafeInteger operator*(const SafeInteger& other) const {
        check_mul_overflow(value, other.value);
        return SafeInteger(value * other.value);
    }

    T get() const { return value; }
};
```

### 10.2 è¾“å…¥éªŒè¯ä¸æ¸…ç†

#### è¾“å…¥éªŒè¯æ¡†æ¶
```cpp
#include <regex>
#include <functional>

class InputValidator {
public:
    struct ValidationRule {
        std::string name;
        std::function<bool(const std::string&)> validator;
        std::string error_message;
    };

private:
    std::vector<ValidationRule> rules;

public:
    void addRule(const std::string& name,
                 std::function<bool(const std::string&)> validator,
                 const std::string& error_message) {
        rules.push_back({name, validator, error_message});
    }

    struct ValidationResult {
        bool is_valid;
        std::vector<std::string> errors;
    };

    ValidationResult validate(const std::string& input) const {
        ValidationResult result{true, {}};

        for (const auto& rule : rules) {
            if (!rule.validator(input)) {
                result.is_valid = false;
                result.errors.push_back(rule.error_message);
            }
        }

        return result;
    }

    // é¢„å®šä¹‰éªŒè¯å™¨
    static std::function<bool(const std::string&)> emailValidator() {
        return [](const std::string& email) {
            std::regex email_regex(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})");
            return std::regex_match(email, email_regex);
        };
    }

    static std::function<bool(const std::string&)> lengthValidator(size_t min, size_t max) {
        return [min, max](const std::string& input) {
            return input.length() >= min && input.length() <= max;
        };
    }

    static std::function<bool(const std::string&)> alphanumericValidator() {
        return [](const std::string& input) {
            return std::all_of(input.begin(), input.end(),
                             [](char c) { return std::isalnum(c); });
        };
    }
};

// ä½¿ç”¨ç¤ºä¾‹
void validate_user_input() {
    InputValidator email_validator;
    email_validator.addRule("format", InputValidator::emailValidator(),
                           "Invalid email format");
    email_validator.addRule("length", InputValidator::lengthValidator(5, 100),
                           "Email must be between 5 and 100 characters");

    std::string user_email = "user@example.com";
    auto result = email_validator.validate(user_email);

    if (!result.is_valid) {
        for (const auto& error : result.errors) {
            std::cerr << "Validation error: " << error << std::endl;
        }
    }
}
```

### 10.3 åŠ å¯†ä¸æ•°æ®ä¿æŠ¤

#### å®‰å…¨çš„å¯†ç å¤„ç†
```cpp
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>

class SecurePassword {
private:
    static constexpr size_t SALT_LENGTH = 32;
    static constexpr size_t HASH_LENGTH = 64;
    static constexpr int ITERATIONS = 100000;

public:
    struct HashedPassword {
        std::vector<uint8_t> salt;
        std::vector<uint8_t> hash;
    };

    static HashedPassword hashPassword(const std::string& password) {
        HashedPassword result;
        result.salt.resize(SALT_LENGTH);
        result.hash.resize(HASH_LENGTH);

        // ç”Ÿæˆéšæœºç›
        if (RAND_bytes(result.salt.data(), SALT_LENGTH) != 1) {
            throw std::runtime_error("Failed to generate salt");
        }

        // ä½¿ç”¨PBKDF2è¿›è¡Œå¯†ç å“ˆå¸Œ
        if (PKCS5_PBKDF2_HMAC(password.c_str(), password.length(),
                              result.salt.data(), SALT_LENGTH,
                              ITERATIONS, EVP_sha256(),
                              HASH_LENGTH, result.hash.data()) != 1) {
            throw std::runtime_error("Failed to hash password");
        }

        return result;
    }

    static bool verifyPassword(const std::string& password,
                              const HashedPassword& stored) {
        std::vector<uint8_t> computed_hash(HASH_LENGTH);

        if (PKCS5_PBKDF2_HMAC(password.c_str(), password.length(),
                              stored.salt.data(), stored.salt.size(),
                              ITERATIONS, EVP_sha256(),
                              HASH_LENGTH, computed_hash.data()) != 1) {
            return false;
        }

        // ä½¿ç”¨å¸¸é‡æ—¶é—´æ¯”è¾ƒé˜²æ­¢æ—¶åºæ”»å‡»
        return CRYPTO_memcmp(computed_hash.data(), stored.hash.data(), HASH_LENGTH) == 0;
    }
};
```

---

## 11. æ–‡æ¡£é©±åŠ¨å¼€å‘

### 11.1 APIæ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆ

#### Doxygené…ç½®ä¼˜åŒ–
```doxygen
# Doxyfile
PROJECT_NAME           = "CrossPlatform SDK"
PROJECT_VERSION        = "1.0.0"
PROJECT_BRIEF          = "é«˜æ€§èƒ½è·¨å¹³å°å¼€å‘SDK"

OUTPUT_DIRECTORY       = docs
CREATE_SUBDIRS         = YES

INPUT                  = src/ include/ examples/
RECURSIVE              = YES
FILE_PATTERNS          = *.cpp *.h *.hpp *.md

EXTRACT_ALL            = YES
EXTRACT_PRIVATE        = NO
EXTRACT_STATIC         = YES
EXTRACT_LOCAL_CLASSES  = YES

GENERATE_HTML          = YES
HTML_OUTPUT            = html
HTML_COLORSTYLE_HUE    = 220
HTML_COLORSTYLE_SAT    = 100
HTML_COLORSTYLE_GAMMA  = 80

GENERATE_LATEX         = NO
GENERATE_XML           = YES

HAVE_DOT               = YES
DOT_IMAGE_FORMAT       = svg
INTERACTIVE_SVG        = YES
DOT_GRAPH_MAX_NODES    = 100

CALL_GRAPH             = YES
CALLER_GRAPH           = YES
GRAPHICAL_HIERARCHY    = YES
DIRECTORY_GRAPH        = YES

PREDEFINED             = DOXYGEN_SHOULD_SKIP_THIS
```

---

## 12. ç›‘æ§ä¸å¯è§‚æµ‹æ€§

### 12.1 æ€§èƒ½ç›‘æ§ç³»ç»Ÿ

#### æŒ‡æ ‡æ”¶é›†æ¡†æ¶
```cpp
#include <chrono>
#include <unordered_map>
#include <atomic>
#include <mutex>

class MetricsCollector {
public:
    struct Metric {
        std::atomic<double> value{0.0};
        std::atomic<uint64_t> count{0};
        std::atomic<double> sum{0.0};
        std::atomic<double> min{std::numeric_limits<double>::max()};
        std::atomic<double> max{std::numeric_limits<double>::lowest()};
    };

private:
    std::unordered_map<std::string, std::unique_ptr<Metric>> metrics_;
    mutable std::shared_mutex metrics_mutex_;

public:
    static MetricsCollector& getInstance() {
        static MetricsCollector instance;
        return instance;
    }

    void recordValue(const std::string& name, double value) {
        auto metric = getOrCreateMetric(name);

        metric->value.store(value);
        metric->count.fetch_add(1);
        metric->sum.fetch_add(value);

        // æ›´æ–°æœ€å°å€¼å’Œæœ€å¤§å€¼
        double current_min = metric->min.load();
        while (value < current_min &&
               !metric->min.compare_exchange_weak(current_min, value)) {}

        double current_max = metric->max.load();
        while (value > current_max &&
               !metric->max.compare_exchange_weak(current_max, value)) {}
    }

    struct MetricSnapshot {
        double current_value;
        uint64_t count;
        double sum;
        double min;
        double max;
        double average;
    };

    MetricSnapshot getSnapshot(const std::string& name) const {
        std::shared_lock lock(metrics_mutex_);
        auto it = metrics_.find(name);
        if (it == metrics_.end()) {
            return {0.0, 0, 0.0, 0.0, 0.0, 0.0};
        }

        auto& metric = *it->second;
        uint64_t count = metric.count.load();
        double sum = metric.sum.load();

        return {
            metric.value.load(),
            count,
            sum,
            metric.min.load(),
            metric.max.load(),
            count > 0 ? sum / count : 0.0
        };
    }

private:
    Metric* getOrCreateMetric(const std::string& name) {
        std::shared_lock lock(metrics_mutex_);
        auto it = metrics_.find(name);
        if (it != metrics_.end()) {
            return it->second.get();
        }

        std::unique_lock ulock(metrics_mutex_);
        auto metric = std::make_unique<Metric>();
        auto* ptr = metric.get();
        metrics_[name] = std::move(metric);
        return ptr;
    }
};

// æ€§èƒ½è®¡æ—¶å™¨
class Timer {
private:
    std::string metric_name_;
    std::chrono::high_resolution_clock::time_point start_time_;

public:
    Timer(const std::string& metric_name)
        : metric_name_(metric_name), start_time_(std::chrono::high_resolution_clock::now()) {}

    ~Timer() {
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            end_time - start_time_).count();

        MetricsCollector::getInstance().recordValue(metric_name_, duration);
    }
};

#define MEASURE_TIME(name) Timer timer(name)
#define MEASURE_FUNCTION() Timer timer(__FUNCTION__)
```

---

## 13. æŠ€æœ¯å€ºåŠ¡ç®¡ç†

### 13.1 æŠ€æœ¯å€ºåŠ¡è¯†åˆ«ä¸é‡åŒ–

#### æŠ€æœ¯å€ºåŠ¡è¯„ä¼°æ¡†æ¶
```python
#!/usr/bin/env python3
"""
æŠ€æœ¯å€ºåŠ¡è¯„ä¼°å·¥å…·
"""

import os
import re
import json
from typing import Dict, List, Tuple
from dataclasses import dataclass
from enum import Enum

class DebtSeverity(Enum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

@dataclass
class TechnicalDebt:
    file_path: str
    line_number: int
    debt_type: str
    severity: DebtSeverity
    description: str
    estimated_hours: float
    business_impact: str

class TechnicalDebtAnalyzer:
    def __init__(self):
        self.debt_patterns = {
            'TODO': {
                'pattern': r'//\s*TODO[:\s]*(.*)',
                'severity': DebtSeverity.MEDIUM,
                'hours': 2.0
            },
            'FIXME': {
                'pattern': r'//\s*FIXME[:\s]*(.*)',
                'severity': DebtSeverity.HIGH,
                'hours': 4.0
            },
            'HACK': {
                'pattern': r'//\s*HACK[:\s]*(.*)',
                'severity': DebtSeverity.HIGH,
                'hours': 6.0
            },
            'XXX': {
                'pattern': r'//\s*XXX[:\s]*(.*)',
                'severity': DebtSeverity.CRITICAL,
                'hours': 8.0
            },
            'deprecated': {
                'pattern': r'@deprecated|DEPRECATED',
                'severity': DebtSeverity.MEDIUM,
                'hours': 3.0
            },
            'magic_number': {
                'pattern': r'\b\d{2,}\b(?!\s*[;,)])',
                'severity': DebtSeverity.LOW,
                'hours': 0.5
            },
            'long_function': {
                'pattern': None,  # éœ€è¦ç‰¹æ®Šå¤„ç†
                'severity': DebtSeverity.MEDIUM,
                'hours': 4.0
            }
        }

    def analyze_file(self, file_path: str) -> List[TechnicalDebt]:
        """åˆ†æå•ä¸ªæ–‡ä»¶çš„æŠ€æœ¯å€ºåŠ¡"""
        debts = []

        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        for line_num, line in enumerate(lines, 1):
            for debt_type, config in self.debt_patterns.items():
                if config['pattern'] and re.search(config['pattern'], line):
                    match = re.search(config['pattern'], line)
                    description = match.group(1) if match.groups() else line.strip()

                    debts.append(TechnicalDebt(
                        file_path=file_path,
                        line_number=line_num,
                        debt_type=debt_type,
                        severity=config['severity'],
                        description=description,
                        estimated_hours=config['hours'],
                        business_impact=self._assess_business_impact(debt_type, description)
                    ))

        # æ£€æŸ¥é•¿å‡½æ•°
        debts.extend(self._check_long_functions(file_path, lines))

        return debts

    def _check_long_functions(self, file_path: str, lines: List[str]) -> List[TechnicalDebt]:
        """æ£€æŸ¥é•¿å‡½æ•°"""
        debts = []
        current_function = None
        brace_count = 0
        function_start = 0

        for line_num, line in enumerate(lines, 1):
            # ç®€åŒ–çš„å‡½æ•°æ£€æµ‹
            func_match = re.search(r'(\w+)\s+(\w+)\s*\([^)]*\)\s*\{', line)
            if func_match:
                current_function = func_match.group(2)
                function_start = line_num
                brace_count = 1
                continue

            if current_function:
                brace_count += line.count('{') - line.count('}')

                if brace_count == 0:
                    # å‡½æ•°ç»“æŸ
                    function_length = line_num - function_start
                    if function_length > 50:  # è¶…è¿‡50è¡Œè®¤ä¸ºæ˜¯é•¿å‡½æ•°
                        debts.append(TechnicalDebt(
                            file_path=file_path,
                            line_number=function_start,
                            debt_type='long_function',
                            severity=DebtSeverity.MEDIUM,
                            description=f"Function '{current_function}' is {function_length} lines long",
                            estimated_hours=4.0,
                            business_impact="Reduces maintainability and readability"
                        ))
                    current_function = None

        return debts

    def _assess_business_impact(self, debt_type: str, description: str) -> str:
        """è¯„ä¼°ä¸šåŠ¡å½±å“"""
        impact_map = {
            'TODO': "Feature incompleteness",
            'FIXME': "Potential bugs or issues",
            'HACK': "Code quality and maintainability",
            'XXX': "Critical issues requiring immediate attention",
            'deprecated': "Future compatibility issues",
            'magic_number': "Code readability and maintainability",
            'long_function': "Code maintainability and testability"
        }
        return impact_map.get(debt_type, "Unknown impact")

    def generate_report(self, source_dirs: List[str], output_file: str):
        """ç”ŸæˆæŠ€æœ¯å€ºåŠ¡æŠ¥å‘Š"""
        all_debts = []

        for source_dir in source_dirs:
            for root, dirs, files in os.walk(source_dir):
                for file in files:
                    if file.endswith(('.cpp', '.c', '.h', '.hpp')):
                        file_path = os.path.join(root, file)
                        try:
                            debts = self.analyze_file(file_path)
                            all_debts.extend(debts)
                        except Exception as e:
                            print(f"Error analyzing {file_path}: {e}")

        # æŒ‰ä¸¥é‡ç¨‹åº¦æ’åº
        all_debts.sort(key=lambda x: x.severity.value, reverse=True)

        # è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        total_hours = sum(debt.estimated_hours for debt in all_debts)
        severity_counts = {}
        for severity in DebtSeverity:
            severity_counts[severity.name] = len([d for d in all_debts if d.severity == severity])

        report = {
            'summary': {
                'total_debts': len(all_debts),
                'estimated_hours': total_hours,
                'estimated_days': total_hours / 8,
                'severity_breakdown': severity_counts
            },
            'debts': [
                {
                    'file': debt.file_path,
                    'line': debt.line_number,
                    'type': debt.debt_type,
                    'severity': debt.severity.name,
                    'description': debt.description,
                    'estimated_hours': debt.estimated_hours,
                    'business_impact': debt.business_impact
                }
                for debt in all_debts
            ]
        }

        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)

        print(f"Technical debt report generated: {output_file}")
        print(f"Total debts: {len(all_debts)}")
        print(f"Estimated effort: {total_hours:.1f} hours ({total_hours/8:.1f} days)")
        print("Severity breakdown:")
        for severity, count in severity_counts.items():
            print(f"  {severity}: {count}")

def main():
    analyzer = TechnicalDebtAnalyzer()
    analyzer.generate_report(['src/', 'include/'], 'technical_debt_report.json')

if __name__ == "__main__":
    main()
```

### 13.2 æŠ€æœ¯å€ºåŠ¡å¿è¿˜ç­–ç•¥

#### å€ºåŠ¡å¿è¿˜ä¼˜å…ˆçº§çŸ©é˜µ
```
å½±å“ vs åŠªåŠ›çŸ©é˜µ:

é«˜å½±å“ | å¿«é€Ÿèƒœåˆ©     | ä¸»è¦é¡¹ç›®
      | (é«˜ä¼˜å…ˆçº§)   | (ä¸­ä¼˜å…ˆçº§)
      |-------------|-------------
      | å¡«è¡¥ç©ºç™½     | æ„Ÿè°¢ä»»åŠ¡
ä½å½±å“ | (ä½ä¼˜å…ˆçº§)   | (æœ€ä½ä¼˜å…ˆçº§)
      |-------------|-------------
       ä½åŠªåŠ›        é«˜åŠªåŠ›

ä¼˜å…ˆçº§è®¡ç®—å…¬å¼:
Priority = (Business_Impact * 0.4) + (Technical_Risk * 0.3) + (Effort_Inverse * 0.3)
```

---

## 14. å®æˆ˜æ¡ˆä¾‹åˆ†æ

### 14.1 æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

#### æ¡ˆä¾‹ï¼šHTTPå®¢æˆ·ç«¯æ€§èƒ½ä¼˜åŒ–

**é—®é¢˜æè¿°**ï¼š
HTTPå®¢æˆ·ç«¯åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹æ€§èƒ½ä¸ä½³ï¼ŒCPUä½¿ç”¨ç‡é«˜ï¼Œå“åº”æ—¶é—´é•¿ã€‚

**åˆ†æè¿‡ç¨‹**ï¼š
```cpp
// åŸå§‹å®ç°ï¼ˆæ€§èƒ½é—®é¢˜ï¼‰
class HttpClientV1 {
private:
    std::mutex connection_mutex_;
    std::vector<Connection> connections_;

public:
    HttpResponse request(const HttpRequest& req) {
        std::lock_guard<std::mutex> lock(connection_mutex_);  // å…¨å±€é”

        // æ¯æ¬¡éƒ½åˆ›å»ºæ–°è¿æ¥
        auto conn = createConnection(req.getUrl());
        auto response = conn.send(req);
        conn.close();  // ç«‹å³å…³é—­è¿æ¥

        return response;
    }
};

// ä¼˜åŒ–åå®ç°
class HttpClientV2 {
private:
    // ä½¿ç”¨è¿æ¥æ± 
    class ConnectionPool {
    private:
        std::unordered_map<std::string, std::queue<std::unique_ptr<Connection>>> pools_;
        std::shared_mutex pools_mutex_;

    public:
        std::unique_ptr<Connection> acquire(const std::string& host) {
            std::unique_lock lock(pools_mutex_);
            auto& pool = pools_[host];

            if (!pool.empty()) {
                auto conn = std::move(pool.front());
                pool.pop();
                return conn;
            }

            lock.unlock();
            return std::make_unique<Connection>(host);
        }

        void release(const std::string& host, std::unique_ptr<Connection> conn) {
            if (conn && conn->isAlive()) {
                std::unique_lock lock(pools_mutex_);
                pools_[host].push(std::move(conn));
            }
        }
    };

    ConnectionPool connection_pool_;

public:
    HttpResponse request(const HttpRequest& req) {
        auto host = extractHost(req.getUrl());
        auto conn = connection_pool_.acquire(host);

        try {
            auto response = conn->send(req);
            connection_pool_.release(host, std::move(conn));
            return response;
        } catch (...) {
            // è¿æ¥å‡ºé”™ï¼Œä¸æ”¾å›æ± ä¸­
            throw;
        }
    }
};
```

**ä¼˜åŒ–ç»“æœ**ï¼š
- ååé‡æå‡ï¼š300% (100 req/s â†’ 400 req/s)
- å¹³å‡å“åº”æ—¶é—´ï¼šå‡å°‘60% (500ms â†’ 200ms)
- CPUä½¿ç”¨ç‡ï¼šé™ä½40%
- å†…å­˜ä½¿ç”¨ï¼šç¨³å®šï¼ˆé¿å…é¢‘ç¹åˆ›å»º/é”€æ¯è¿æ¥ï¼‰

### 14.2 å†…å­˜æ³„æ¼ä¿®å¤æ¡ˆä¾‹

#### æ¡ˆä¾‹ï¼šæ™ºèƒ½æŒ‡é’ˆå¾ªç¯å¼•ç”¨

**é—®é¢˜æè¿°**ï¼š
ç¨‹åºè¿è¡Œä¸€æ®µæ—¶é—´åå†…å­˜æŒç»­å¢é•¿ï¼Œæœ€ç»ˆå¯¼è‡´OOMã€‚

**é—®é¢˜ä»£ç **ï¼š
```cpp
// å¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ³„æ¼
class Node {
public:
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> parent;  // é—®é¢˜ï¼šä¸å­èŠ‚ç‚¹å½¢æˆå¾ªç¯å¼•ç”¨
    std::vector<std::shared_ptr<Node>> children;

    void addChild(std::shared_ptr<Node> child) {
        children.push_back(child);
        child->parent = shared_from_this();  // å¾ªç¯å¼•ç”¨ï¼
    }
};
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```cpp
// ä½¿ç”¨weak_ptræ‰“ç ´å¾ªç¯å¼•ç”¨
class Node : public std::enable_shared_from_this<Node> {
public:
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> parent;  // ä½¿ç”¨weak_ptr
    std::vector<std::shared_ptr<Node>> children;

    void addChild(std::shared_ptr<Node> child) {
        children.push_back(child);
        child->parent = shared_from_this();  // ç°åœ¨æ˜¯weak_ptrï¼Œä¸ä¼šå¾ªç¯å¼•ç”¨
    }

    std::shared_ptr<Node> getParent() {
        return parent.lock();  // å®‰å…¨åœ°è·å–parent
    }
};
```

**éªŒè¯å·¥å…·**ï¼š
```bash
# ä½¿ç”¨Valgrindæ£€æµ‹å†…å­˜æ³„æ¼
valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./program

# ä½¿ç”¨AddressSanitizer
g++ -fsanitize=address -g program.cpp -o program
./program
```

---

## 15. æ€»ç»“ä¸æœ€ä½³å®è·µ

### 15.1 ä»£ç è´¨é‡æ£€æŸ¥æ¸…å•

#### æ—¥å¸¸å¼€å‘æ£€æŸ¥æ¸…å•
- [ ] **ç¼–è¯‘æ£€æŸ¥**ï¼šæ— è­¦å‘Šç¼–è¯‘é€šè¿‡
- [ ] **é™æ€åˆ†æ**ï¼šClang-Tidyã€Cppchecké€šè¿‡
- [ ] **ä»£ç æ ¼å¼**ï¼šç¬¦åˆå›¢é˜Ÿç¼–ç è§„èŒƒ
- [ ] **å•å…ƒæµ‹è¯•**ï¼šæ–°ä»£ç æœ‰å¯¹åº”æµ‹è¯•ï¼Œè¦†ç›–ç‡>80%
- [ ] **æ–‡æ¡£æ›´æ–°**ï¼šAPIå˜æ›´æœ‰å¯¹åº”æ–‡æ¡£æ›´æ–°
- [ ] **æ€§èƒ½è€ƒè™‘**ï¼šå…³é”®è·¯å¾„æœ‰æ€§èƒ½æµ‹è¯•
- [ ] **å®‰å…¨æ£€æŸ¥**ï¼šè¾“å…¥éªŒè¯ã€å†…å­˜å®‰å…¨
- [ ] **é”™è¯¯å¤„ç†**ï¼šå¼‚å¸¸æƒ…å†µæœ‰é€‚å½“å¤„ç†

#### ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•
- [ ] **åŠŸèƒ½æ­£ç¡®æ€§**ï¼šå®ç°ç¬¦åˆéœ€æ±‚
- [ ] **è®¾è®¡åˆç†æ€§**ï¼šéµå¾ªSOLIDåŸåˆ™
- [ ] **æ€§èƒ½å½±å“**ï¼šæ— æ˜æ˜¾æ€§èƒ½é—®é¢˜
- [ ] **å®‰å…¨æ€§**ï¼šæ— å®‰å…¨æ¼æ´
- [ ] **å¯ç»´æŠ¤æ€§**ï¼šä»£ç æ¸…æ™°æ˜“æ‡‚
- [ ] **æµ‹è¯•å……åˆ†æ€§**ï¼šæµ‹è¯•è¦†ç›–å…³é”®åœºæ™¯
- [ ] **å‘åå…¼å®¹**ï¼šä¸ç ´åç°æœ‰API

### 15.2 å·¥å…·é“¾æ¨è

#### å¿…å¤‡å·¥å…·
```bash
# ç¼–è¯‘å™¨
gcc-11 æˆ– clang-13+

# é™æ€åˆ†æ
clang-tidy
cppcheck
PVS-Studio (å•†ä¸š)

# åŠ¨æ€åˆ†æ
valgrind
AddressSanitizer
ThreadSanitizer

# æµ‹è¯•æ¡†æ¶
Google Test + Google Mock
Catch2

# æ€§èƒ½åˆ†æ
Google Benchmark
perf
Intel VTune (å•†ä¸š)

# æ–‡æ¡£ç”Ÿæˆ
Doxygen
Sphinx

# æ„å»ºç³»ç»Ÿ
CMake 3.20+
Ninja

# ç‰ˆæœ¬æ§åˆ¶
Git + GitHub/GitLab

# CI/CD
GitHub Actions
Jenkins
GitLab CI
```

### 15.3 å›¢é˜Ÿåä½œå»ºè®®

#### å¼€å‘æµç¨‹
1. **éœ€æ±‚åˆ†æ** â†’ æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡
2. **æ¶æ„è®¾è®¡** â†’ ADRæ–‡æ¡£è®°å½•
3. **æ¥å£è®¾è®¡** â†’ APIæ–‡æ¡£å…ˆè¡Œ
4. **å®ç°å¼€å‘** â†’ TDD/BDDæ–¹å¼
5. **ä»£ç å®¡æŸ¥** â†’ åŒè¡Œè¯„å®¡
6. **é›†æˆæµ‹è¯•** â†’ è‡ªåŠ¨åŒ–æµ‹è¯•
7. **æ€§èƒ½æµ‹è¯•** â†’ åŸºå‡†æµ‹è¯•
8. **éƒ¨ç½²å‘å¸ƒ** â†’ ç°åº¦å‘å¸ƒ

#### è´¨é‡æ–‡åŒ–å»ºè®¾
- **é›¶å®¹å¿æ€åº¦**ï¼šå¯¹ç¼–è¯‘è­¦å‘Šã€æµ‹è¯•å¤±è´¥
- **æŒç»­æ”¹è¿›**ï¼šå®šæœŸæŠ€æœ¯å€ºåŠ¡æ¸…ç†
- **çŸ¥è¯†åˆ†äº«**ï¼šæŠ€æœ¯åˆ†äº«ä¼šã€ä»£ç èµ°è¯»
- **å·¥å…·æŠ•èµ„**ï¼šæŒç»­æ”¹è¿›å¼€å‘å·¥å…·é“¾
- **åº¦é‡é©±åŠ¨**ï¼šåŸºäºæ•°æ®çš„è´¨é‡æ”¹è¿›

---

## ğŸ¯ ç»“è¯­

ä»£ç è´¨é‡ä¸æ˜¯ä¸€è¹´è€Œå°±çš„ï¼Œéœ€è¦ï¼š

1. **å·¥å…·æ”¯æ’‘**ï¼šå®Œå–„çš„å·¥å…·é“¾æ˜¯åŸºç¡€
2. **æµç¨‹ä¿éšœ**ï¼šè§„èŒƒçš„å¼€å‘æµç¨‹æ˜¯å…³é”®
3. **æ–‡åŒ–å»ºè®¾**ï¼šå›¢é˜Ÿè´¨é‡æ„è¯†æ˜¯æ ¸å¿ƒ
4. **æŒç»­æ”¹è¿›**ï¼šåŸºäºåº¦é‡çš„æŒç»­ä¼˜åŒ–

è®°ä½ï¼š**è´¨é‡æ˜¯è®¾è®¡å‡ºæ¥çš„ï¼Œä¸æ˜¯æµ‹è¯•å‡ºæ¥çš„ã€‚**

---

*æœ¬æ–‡æ¡£å°†æŒç»­æ›´æ–°ï¼Œæ¬¢è¿è´¡çŒ®æ”¹è¿›å»ºè®®ã€‚*